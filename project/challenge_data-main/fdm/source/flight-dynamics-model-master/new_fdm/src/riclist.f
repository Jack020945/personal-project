c	This is RICPACK with some minor changes for newer fortran.
c	James Walker   SwRI   7 July 2021

      SUBROUTINE BALGBK (N,MZ,Z,M,LOW,IGH,CSCALE,CPERM)
C
C     *****PARAMETERS:
      INTEGER IGH,LOW,M,MZ,N
      DOUBLE PRECISION CPERM(N),CSCALE(N),Z(MZ,N)
C
C     *****LOCAL VARIABLES:
C     NONE
C
C     *****FUNCTIONS:
C     NONE
C
C     *****SUBROUTINES CALLED:
C     GRADBK, SCALBK
C
C     ---------------------------------------------------------------
C
C     *****PURPOSE:
C     THIS SUBROUTINE BACK TRANSFORMS THE EIGENVECTORS OF A
C     GENERALIZED EIGENVALUE PROBLEM A*X = (LAMBDA)*B*X, THAT WAS
C     BALANCED BY SUBROUTINE BALGEN, TO THOSE OF THE ORIGINAL
C     PROBLEM.
C     REF.:  WARD, R. C., BALANCING THE GENERALIZED EIGENVALUE
C     PROBLEM, SIAM J. SCI. STAT. COMPUT., VOL. 2, NO. 2, JUNE 1981,
C     141-152.
C
C     *****PARAMETER DESCRIPTION:
C
C     ON INPUT:
C
C       MZ      INTEGER
C               ROW DIMENSION OF THE ARRAY Z AS SPECIFIED IN THE MAIN
C               CALLING PROGRAM DIMENSION STATEMENT;
C
C       N       INTEGER
C               ORDER OF THE MATRICES A AND B IN THE EIGENPROBLEM;
C
C       M       INTEGER
C               SPECIFIES THE NUMBER OF EIGENVECTORS TO BE TRANS-
C               FORMED;
C
C       Z       REAL(MZ,N)
C               CONTAINS THE EIGENVECTORS TO BE TRANSFORMED;
C
C       LOW     INTEGER
C               SPECIFIES THE BEGINNING INDEX OF THE SUBMATRICES OF
C               A AND B WHICH WERE BALANCED;
C
C       IGH     INTEGER
C               SPECIFIES THE ENDING INDEX OF THE SUBMATRICES OF
C               A AND B WHICH WERE BALANCED;
C
C       CSCALE  REAL(N)
C               CONTAINS THE REDUCING COLUMN PERMUTATIONS AND SCALING
C               INFORMATION AS RETURNED FROM BALGEN;
C
C       CPERM   REAL(N)
C               CONTAINS IN ITS LOW THROUGH IGH LOCATIONS THE COLUMN
C               PERMUTATIONS APPLIED IN GRADING THE A AND B
C               SUBMATRICES AS RETURNED FROM BALGEN.
C
C     ON OUTPUT:
C
C       Z       CONTAINS THE TRANSFORMED EIGENVECTORS.
C
C     *****ALGORITHM NOTES:
C     NONE
C
C     *****HISTORY:
C     WRITTEN BY R. C. WARD.......
C
C     ---------------------------------------------------------------
C
      CALL GRADBK (N,MZ,Z,M,LOW,IGH,CPERM)
      CALL SCALBK (N,MZ,Z,M,LOW,IGH,CSCALE)
      RETURN
C
C     LAST LINE OF BALGBK
C
      END
      SUBROUTINE BALGEN (N,MA,A,MB,B,LOW,IGH,CSCALE,CPERM,WK)
C
C     *****PARAMETERS:
      INTEGER IGH,LOW,MA,MB,N
      DOUBLE PRECISION A(MA,N),B(MB,N),CPERM(N),CSCALE(N),WK(N,6)
C
C     *****LOCAL VARIABLES:
C     NONE
C
C     *****FUNCTIONS:
C     NONE
C
C     *****SUBROUTINES CALLED:
C     REDUCE, SCALEG, GRADEQ
C
C     ---------------------------------------------------------------
C
C     *****PURPOSE:
C     THIS SUBROUTINE BALANCES THE MATRICES A AND B TO IMPROVE THE
C     ACCURACY OF COMPUTING THE EIGENSYSTEM OF THE GENERALIZED
C     EIGENPROBLEM A*X = (LAMBDA)*B*X.  THE ALGORITHM IS SPECIFICALLY
C     DESIGNED TO PRECEDE QZ TYPE ALGORITHMS, BUT IMPROVED PERFORMANCE
C     IS EXPECTED FROM MOST EIGENSYSTEM SOLVERS.
C     REF.:  WARD, R. C., BALANCING THE GENERALIZED EIGENVALUE
C     PROBLEM, SIAM J. SCI. STAT. COMPUT., VOL. 2, NO. 2, JUNE 1981,
C     141-152.
C
C     *****PARAMETER DESCRIPTION:
C
C     ON INPUT:
C
C       MA,MB   INTEGER
C               ROW DIMENSIONS OF THE ARRAYS CONTAINING MATRICES
C               A AND B RESPECTIVELY, AS DECLARED IN THE MAIN CALLING
C               PROGRAM DIMENSION STATEMENT;
C
C       N       INTEGER
C               ORDER OF THE MATRICES A AND B;
C
C       A       REAL(MA,N)
C               CONTAINS THE A MATRIX OF THE GENERALIZED EIGENPROBLEM
C               DEFINED ABOVE;
C
C       B       REAL(MB,N)
C               CONTAINS THE B MATRIX OF THE GENERALIZED EIGENPROBLEM
C               DEFINED ABOVE;
C
C       WK      REAL(N,6)
C               WORK ARRAY THAT MUST CONTAIN AT LEAST 6*N STORAGE
C               LOCATIONS.  WK IS ALTERED BY THIS SUBROUTINE.
C
C     ON OUTPUT:
C
C       A,B     CONTAIN THE BALANCED A AND B MATRICES;
C
C       LOW     INTEGER
C               BEGINNING INDEX OF THE SUBMATRICES OF A AND B
C               CONTAINING THE NON-ISOLATED EIGENVALUES;
C
C       IGH     INTEGER
C               ENDING INDEX OF THE SUBMATRICES OF A AND B
C               CONTAINING THE NON-ISOLATED EIGENVALUES.  IF
C               IGH = 1 (LOW = 1 ALSO), THE A AND B MATRICES HAVE
C               BEEN PERMUTED INTO UPPER TRIANGULAR FORM AND HAVE
C               NOT BEEN BALANCED;
C
C       CSCALE  REAL(N)
C               CONTAINS THE EXPONENTS OF THE COLUMN SCALING FACTORS
C               IN ITS LOW THROUGH IGH LOCATIONS AND THE REDUCING
C               COLUMN PERMUTATIONS IN ITS FIRST LOW-1 AND ITS
C               IGH+1 THROUGH N LOCATIONS;
C
C       CPERM   REAL(N)
C               CONTAINS THE COLUMN PERMUTATIONS APPLIED IN GRADING
C               THE A AND B SUBMATRICES IN ITS LOW THROUGH IGH
C               LOCATIONS;
C
C       WK      CONTAINS THE EXPONENTS OF THE ROW SCALING FACTORS
C               IN ITS LOW THROUGH IGH LOCATIONS, THE REDUCING ROW
C               PERMUTATIONS IN ITS FIRST LOW-1 AND ITS IGH+1
C               THROUGH N LOCATIONS, AND THE ROW PERMUTATIONS
C               APPLIED IN GRADING THE A AND B SUBMATRICES IN ITS
C               N+LOW THROUGH N+IGH LOCATIONS.
C
C     *****ALGORITHM NOTES:
C     NONE
C
C     *****HISTORY:
C     WRITTEN BY R. C. WARD.......
C
C     ---------------------------------------------------------------
C
      CALL REDUCE (N,MA,A,MB,B,LOW,IGH,CSCALE,WK)
      IF (LOW .EQ. IGH) GO TO 10
      CALL SCALEG (N,MA,A,MB,B,LOW,IGH,CSCALE,CPERM,WK)
      CALL GRADEQ (N,MA,A,MB,B,LOW,IGH,CPERM,WK(1,2))
   10 CONTINUE
      RETURN
C
C     LAST LINE OF BALGEN
C
      END
      SUBROUTINE DGECOM (A,LDA,N,IPVT,RCOND,Z)
      INTEGER LDA,N,IPVT(N)
      DOUBLE PRECISION A(LDA,N),Z(N)
      DOUBLE PRECISION RCOND
C
C     DGECOM FACTORS A DOUBLE PRECISION MATRIX BY GAUSSIAN ELIMINATION
C     AND ESTIMATES THE CONDITION OF THE MATRIX.
C
C     IF RCOND IS NOT NEEDED, DGEFAM IS SLIGHTLY FASTER.
C     TO SOLVE  A*X = B , FOLLOW DGECOM BY DGESLM.
C     TO COMPUTE  INVERSE(A)*C , FOLLOW DGECOM BY DGESLM.
C
C     ON ENTRY:
C
C        A       DOUBLE PRECISION(LDA,N)
C                THE MATRIX TO BE FACTORED.
C
C        LDA     INTEGER
C                THE LEADING DIMENSION OF THE ARRAY A AS DECLARED
C                IN THE MAIN CALLING PROGRAM.
C
C        N       INTEGER
C                THE ORDER OF THE MATRIX A.
C
C     ON RETURN:
C
C        A       AN UPPER TRIANGULAR MATRIX AND THE MULTIPLIERS
C                WHICH WERE USED TO OBTAIN IT.
C                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE
C                L IS A PRODUCT OF PERMUTATION AND UNIT LOWER
C                TRIANGULAR MATRICES AND U IS UPPER TRIANGULAR.
C
C        IPVT    INTEGER(N)
C                AN INTEGER VECTOR OF PIVOT INDICES.
C                   IPVT(K) = THE INDEX OF THE K-TH PIVOT ROW
C                THE DETERMINANT OF A CAN BE OBTAINED ON OUTPUT BY
C                   DET(A) = S*A(1,1)*A(2,2)* ... *A(N,N)
C                WHERE S = (-1)**(NUMBER OF TIMES IPVT(K) .NE. K)
C                BUT THIS RESULT SHOULD BE USED WITH CAUTION AS IT
C                MAY EASILY UNDERFLOW OR OVERFLOW.
C
C        RCOND   DOUBLE PRECISION
C                AN ESTIMATE OF THE RECIPROCAL CONDITION OF A.
C                FOR THE SYSTEM  A*X = B , RELATIVE PERTURBATIONS
C                IN A AND B OF SIZE EPSILON MAY CAUSE RELATIVE
C                PERTURBATIONS IN X OF SIZE  EPSILON/RCOND.
C                IF RCOND IS SO SMALL THAT THE LOGICAL EXPRESSION
C                             1.0D0 + RCOND  .EQ.  1.0D0
C                IS TRUE, THEN A MAY BE SINGULAR TO WORKING
C                PRECISION.  IN PARTICULAR, RCOND IS ZERO IF
C                EXACT SINGULARITY IS DETECTED OR THE ESTIMATE
C                UNDERFLOWS.
C
C        Z       DOUBLE PRECISION(N)
C                A WORK VECTOR WHOSE CONTENTS ARE USUALLY UNIMPORTANT.
C                IF A IS CLOSE TO A SINGULAR MATRIX, THEN Z IS AN
C                APPROXIMATE NULL VECTOR IN THE SENSE THAT
C                       NORM(A*Z) = RCOND*NORM(A)*NORM(Z).
C
C     THIS VERSION IS ADAPTED FROM THE LINPACK SUBROUTINE DGECO BY
C     REPLACEMENT OF CALLS TO THE BLAS WITH IN-LINE CODE.  MODIFICATION
C     DONE BY ALAN J. LAUB, UNIVERSITY OF SOUTHERN CALIFORNIA,
C     APRIL 1980.
C
C     SUBROUTINES AND FUNCTIONS CALLED:
C
C     DGEFAM
C
C     FORTRAN FUNCTIONS CALLED:
C
      DOUBLE PRECISION DABS,DSIGN
C
C     INTERNAL VARIABLES:
C
      INTEGER I,INFO,J,K,KB,KM1,KP1,L
      DOUBLE PRECISION ANORM,EK,S,SM,T,WK,WKM,YNORM
C
C     COMPUTE 1-NORM OF A
C
      ANORM = 0.0D0
      DO 20 J=1,N
         T = 0.0D0
         DO 10 I=1,N
            T = T+DABS(A(I,J))
   10    CONTINUE
         IF (T .GT. ANORM) ANORM = T
   20 CONTINUE
C
C     FACTOR
C
      CALL DGEFAM(A,LDA,N,IPVT,INFO)
C
C     RCOND = 1/(NORM(A)*(ESTIMATE OF NORM(INVERSE(A)))).
C     ESTIMATE = NORM(Z)/NORM(Y)  WHERE  A*Z = Y AND  TRANS(A)*Y = E.
C     TRANS(A)  IS THE TRANSPOSE OF A.  THE COMPONENTS OF E ARE
C     CHOSEN TO CAUSE MAXIMUM LOCAL GROWTH IN THE ELEMENTS OF W WHERE
C     TRANS(U)*W = E .  THE VECTORS ARE FREQUENTLY RESCALED TO AVOID
C     OVERFLOW.
C
C     SOLVE  TRANS(U)*W = E
C
      EK = 1.0D0
      DO 30 I=1,N
         Z(I) = 0.0D0
   30 CONTINUE
      DO 120 K=1,N
         IF (Z(K) .NE. 0.0D0) EK = DSIGN(EK,-Z(K))
         IF (DABS(EK-Z(K)) .LE. DABS(A(K,K))) GO TO 50
         S = DABS(A(K,K))/DABS(EK-Z(K))
         DO 40 I=1,N
            Z(I) = S*Z(I)
   40    CONTINUE
         EK = S*EK
   50    CONTINUE
         WK = EK-Z(K)
         WKM = -EK-Z(K)
         S = DABS(WK)
         SM = DABS(WKM)
         IF (A(K,K) .EQ. 0.0D0) GO TO 60
         WK = WK/A(K,K)
         WKM = WKM/A(K,K)
         GO TO 70
   60    CONTINUE
         WK = 1.0D0
         WKM = 1.0D0
   70    CONTINUE
         KP1 = K+1
         IF (KP1 .GT. N) GO TO 110
         DO 80 J=KP1,N
            SM = SM+DABS(Z(J)+WKM*A(K,J))
            Z(J) = Z(J)+WK*A(K,J)
            S = S+DABS(Z(J))
   80    CONTINUE
         IF (S .GE. SM) GO TO 100
         T = WKM-WK
         WK = WKM
         DO 90 J=KP1,N
            Z(J) = Z(J)+T*A(K,J)
   90    CONTINUE
  100    CONTINUE
  110    CONTINUE
         Z(K) = WK
  120 CONTINUE
      T = 0.0D0
      DO 130 I=1,N
         T = T+DABS(Z(I))
  130 CONTINUE
      S = 1.0D0/T
      DO 140 I=1,N
         Z(I) = S*Z(I)
  140 CONTINUE
C
C     SOLVE  TRANS(L)*Y = W
C
      DO 190 KB=1,N
         K = N+1-KB
         IF (K .EQ. N) GO TO 160
         KP1 = K+1
         T = 0.0D0
         DO 150 I=KP1,N
            T = T+A(I,K)*Z(I)
  150    CONTINUE
         Z(K) = Z(K)-T
  160    CONTINUE
         IF (DABS(Z(K)) .LE. 1.0D0) GO TO 180
         S = 1.0D0/DABS(Z(K))
         DO 170 I=1,N
            Z(I) = S*Z(I)
  170    CONTINUE
  180    CONTINUE
         L = IPVT(K)
         T = Z(L)
         Z(L) = Z(K)
         Z(K) = T
  190 CONTINUE
      T = 0.0D0
      DO 200 I=1,N
         T = T+DABS(Z(I))
  200 CONTINUE
      S = 1.0D0/T
      DO 210 I=1,N
         Z(I) = S*Z(I)
  210 CONTINUE
C
      YNORM = 1.0D0
C
C     SOLVE  L*V = Y
C
      DO 260 K=1,N
         L = IPVT(K)
         T = Z(L)
         Z(L) = Z(K)
         Z(K) = T
         IF (K .EQ. N) GO TO 230
         KP1 = K+1
         DO 220 I=KP1,N
            Z(I) = Z(I)-T*A(I,K)
  220    CONTINUE
  230    CONTINUE
         IF (DABS(Z(K)) .LE. 1.0D0) GO TO 250
         S = 1.0D0/DABS(Z(K))
         DO 240 I=1,N
            Z(I) = S*Z(I)
  240    CONTINUE
         YNORM = S*YNORM
  250    CONTINUE
  260 CONTINUE
      T = 0.0D0
      DO 270 I=1,N
         T = T+DABS(Z(I))
  270 CONTINUE
      S = 1.0D0/T
      DO 280 I=1,N
         Z(I) = S*Z(I)
  280 CONTINUE
      YNORM = S*YNORM
C
C     SOLVE  U*Z = V
C
      DO 330 KB=1,N
         K = N+1-KB
         IF (DABS(Z(K)) .LE. DABS(A(K,K))) GO TO 300
         S = DABS(A(K,K))/DABS(Z(K))
         DO 290 I=1,N
            Z(I) = S*Z(I)
  290    CONTINUE
         YNORM = S*YNORM
  300    CONTINUE
         IF (A(K,K) .NE. 0.0D0) Z(K) = Z(K)/A(K,K)
         IF (A(K,K) .EQ. 0.0D0) Z(K) = 1.0D0
         T = -Z(K)
         IF (K .EQ. 1) GO TO 320
         KM1 = K-1
         DO 310 I=1,KM1
            Z(I) = Z(I)+T*A(I,K)
  310    CONTINUE
  320    CONTINUE
  330 CONTINUE
C
C     MAKE ZNORM = 1.0D0
C
      T = 0.0D0
      DO 340 I=1,N
         T = T+DABS(Z(I))
  340 CONTINUE
      S = 1.0D0/T
      DO 350 I=1,N
         Z(I) = S*Z(I)
  350 CONTINUE
      YNORM = S*YNORM
C
C     DETERMINE RCOND
C
      IF (ANORM .NE. 0.0D0) RCOND = YNORM/ANORM
      IF (ANORM .EQ. 0.0D0) RCOND = 0.0D0
      RETURN
      END
      SUBROUTINE DGEFAM (A,LDA,N,IPVT,INFO)
      INTEGER LDA,N,IPVT(N),INFO
      DOUBLE PRECISION A(LDA,N)
C
C     DGEFAM FACTORS A DOUBLE PRECISION REAL MATRIX BY
C     GAUSSIAN ELIMINATION.
C
C     DGEFAM IS USUALLY CALLED BY DGECOM, BUT IT CAN BE CALLED
C     DIRECTLY WITH A MODEST SAVING IN TIME IF RCOND IS NOT
C     NEEDED.
C
C     ON ENTRY:
C
C        A       DOUBLE PRECISION(LDA,N)
C                THE MATRIX TO BE FACTORED.
C
C        LDA     INTEGER
C                THE LEADING DIMENSION OF THE ARRAY A AS DECLARED
C                IN THE MAIN CALLING PROGRAM.
C
C        N       INTEGER
C                THE ORDER OF THE MATRIX A.
C
C     ON RETURN:
C
C        A       AN UPPER TRIANGULAR MATRIX AND THE MULTIPLIERS
C                WHICH WERE USED TO OBTAIN IT.
C                THE FACTORIZATION CAN BE WRITTEN  A = L * U WHERE
C                L IS A PRODUCT OF PERMUTATION AND UNIT LOWER
C                TRIANGULAR MATRICES AND U IS UPPER TRIANGULAR.
C
C        IPVT    INTEGER(N)
C                AN INTEGER VECTOR OF PIVOT INDICES.
C                   IPVT(K) = THE INDEX OF THE K-TH PIVOT ROW
C                THE DETERMINANT OF A CAN BE OBTAINED ON OUTPUT BY
C                   DET(A) = S*A(1,1)*A(2,2)* ... *A(N,N)
C                WHERE S = (-1)**(NUMBER OF TIMES IPVT(K) .NE. K)
C                BUT THIS RESULT SHOULD BE USED WITH CAUTION AS IT
C                MAY EASILY UNDERFLOW OR OVERFLOW.
C
C        INFO    INTEGER
C                = 0  NORMAL VALUE.
C                = K  IF  U(K,K) .EQ. 0.0D0.  THIS IS NOT AN ERROR
C                     CONDITION FOR THIS SUBROUTINE, BUT IT DOES
C                     INDICATE THAT DGESLM WILL DIVIDE BY ZERO IF
C                     CALLED.
C                     USE RCOND IN DGECOM FOR A RELIABLE INDICATION OF
C                     SINGULARITY.
C
C     THIS VERSION IS ADAPTED FROM THE LINPACK SUBROUTINE DGEFA BY
C     REPLACEMENT OF CALLS TO THE BLAS WITH IN-LINE CODE.  MODIFICATION
C     DONE BY ALAN J. LAUB, UNIVERSITY OF SOUTHERN CALIFORNIA,
C     APRIL 1980.
C
C     FORTRAN FUNCTIONS CALLED:
C
      DOUBLE PRECISION DABS
C
C     INTERNAL VARIABLES:
C
      INTEGER I,J,K,KP1,L,NM1
      DOUBLE PRECISION T
C
C     GAUSSIAN ELIMINATION WITH PARTIAL PIVOTING
C
      IPVT(N) = 1
      INFO = 0
      NM1 = N-1
      IF (NM1 .LT. 1) GO TO 100
      DO 90 K=1,NM1
         KP1 = K+1
C
C        FIND L = PIVOT INDEX
C
         L = K
         DO 10 I=KP1,N
            IF (DABS(A(I,K)) .GT. DABS(A(L,K))) L = I
   10    CONTINUE
         IPVT(K) = L
C
C        ZERO PIVOT IMPLIES THIS COLUMN ALREADY TRIANGULARIZED
C
         IF (A(L,K) .EQ. 0.0D0) GO TO 70
C
C        INTERCHANGE IF NECESSARY
C
         IF (L .EQ. K) GO TO 20
         T = A(L,K)
         A(L,K) = A(K,K)
         A(K,K) = T
   20    CONTINUE
C
C        COMPUTE MULTIPLIERS
C
         T = 1.0D0/A(K,K)
         DO 30 I=KP1,N
            A(I,K) = T*A(I,K)
   30    CONTINUE
C
C        ROW ELIMINATION WITH COLUMN INDEXING
C
         DO 60 J=KP1,N
            T = A(L,J)
            IF (L .EQ. K) GO TO 40
            A(L,J) = A(K,J)
            A(K,J) = T
   40       CONTINUE
            DO 50 I=KP1,N
               A(I,J) = A(I,J)-T*A(I,K)
   50       CONTINUE
   60    CONTINUE
         GO TO 80
   70    CONTINUE
         INFO = K
   80    CONTINUE
   90 CONTINUE
  100 CONTINUE
      IPVT(N) = N
      IF (A(N,N) .EQ. 0.0D0) INFO = N
      RETURN
      END
      SUBROUTINE DGESLM (A,LDA,N,IPVT,B)
      INTEGER LDA,N,IPVT(N)
      DOUBLE PRECISION A(LDA,N),B(N)
C
C     DGESLM SOLVES THE (REAL) LINEAR SYSTEM
C            A * X = B
C     USING THE FACTORS COMPUTED BY DGECOM OR DGEFAM.
C
C     ON ENTRY:
C
C        A       DOUBLE PRECISION(LDA,N)
C                THE OUTPUT FROM DGECOM OR DGEFAM.
C
C        LDA     INTEGER
C                THE LEADING DIMENSION OF THE ARRAY A AS DECLARED
C                IN THE MAIN CALLING PROGRAM.
C
C        N       INTEGER
C                THE ORDER OF THE MATRIX A.
C
C        IPVT    INTEGER(N)
C                THE PIVOT VECTOR FROM DGECOM OR DGEFAM.
C
C        B       DOUBLE PRECISION(N)
C                THE RIGHT HAND SIDE VECTOR.
C
C     ON RETURN:
C
C        B       THE SOLUTION VECTOR X.
C
C     ERROR CONDITION:
C
C        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS A
C        ZERO ON THE DIAGONAL.  TECHNICALLY THIS INDICATES SINGULARITY
C        BUT IT IS OFTEN CAUSED BY IMPROPER ARGUMENTS OR IMPROPER
C        SETTING OF LDA.  IT WILL NOT OCCUR IF THE SUBROUTINES ARE
C        CALLED CORRECTLY AND IF DGECOM HAS SET RCOND .GT. 0.0
C        OR DGEFAM HAS SET INFO .EQ. 0.
C
C     TO COMPUTE  INVERSE(A) * B  WHERE B IS A MATRIX WITH M COLUMNS
C             CALL DGECOM (A,LDA,N,IPVT,RCOND,Z)
C             IF (RCOND IS TOO SMALL) GO TO ...
C             DO 10 J=1,M
C                CALL DGESLM (A,LDA,N,IPVT,B(1,J))
C          10 CONTINUE
C
C     THIS VERSION IS ADAPTED FROM THE LINPACK SUBROUTINE DGESL BY
C     REPLACEMENT OF CALLS TO THE BLAS WITH IN-LINE CODE.  MODIFICA-
C     TION DONE BY ALAN J. LAUB, UNIVERSITY OF SOUTHERN CALIFORNIA,
C     APRIL 1980.
C
C     FORTRAN FUNCTIONS CALLED:
C
C     NONE
C
C     INTERNAL VARIABLES:
C
      INTEGER I,K,KB,KM1,KP1,L,NM1
      DOUBLE PRECISION T
C
      IF (N .EQ. 1) GO TO 60
      NM1 = N-1
C
C     FIRST SOLVE L*Y = B
C
      DO 30 K=1,NM1
         KP1 = K+1
         L = IPVT(K)
         T = B(L)
         IF (L .EQ. K) GO TO 10
         B(L) = B(K)
         B(K) = T
   10    CONTINUE
         DO 20 I=KP1,N
            B(I) = B(I)-T*A(I,K)
   20    CONTINUE
   30 CONTINUE
C
C     NOW SOLVE  U*X = Y
C
      DO 50 KB=1,NM1
         K = N+1-KB
         KM1 = K-1
         B(K) = B(K)/A(K,K)
         T = -B(K)
         DO 40 I=1,KM1
            B(I) = B(I)+T*A(I,K)
   40    CONTINUE
   50 CONTINUE
   60 CONTINUE
      B(1) = B(1)/A(1,1)
      RETURN
      END
      SUBROUTINE EXCHQZ (A,B,Z,NMAX,N,L,LS1,LS2,EPS,IFAIL)
C
C     *****PARAMETERS:
      INTEGER IFAIL,L,LS1,LS2,N,NMAX
      DOUBLE PRECISION EPS,A(NMAX,N),B(NMAX,N),Z(NMAX,N)
C
C     *****LOCAL VARIABLES:
      INTEGER I,IT1,IT2,J,LI,LJ,LL,L1,L2,L3
      DOUBLE PRECISION AMMBMM,AMNBNN,ANMBMM,ANNBNN,A11B11,A12B22,
     X                 A21B11,A22B22,BMNBNN,B12B22,D,E,F,G,SA,SB,
     X                 U(3,3)
      LOGICAL ALTB
C
C     *****FORTRAN FUNCTIONS:
      DOUBLE PRECISION DABS,DMAX1
C
C     *****SUBROUTINES CALLED:
C     GIV, ROTC, ROTR
C
C     ----------------------------------------------------------------
C
C     *****PURPOSE:
C     GIVEN THE UPPER TRIANGULAR MATRIX B AND THE UPPER HESSENBERG
C     MATRIX A WITH CONSECUTIVE LS1XLS1 AND LS2XLS2 DIAGONAL BLOCKS
C     (LS1,LS2 .LE. 2) STARTING AT ROW/COLUMN L, THIS SUBROUTINE
C     PRODUCES EQUIVALENCE TRANSFORMATIONS QT AND ZT THAT EXCHANGE
C     THE BLOCKS ALONG WITH THE GENERALIZED EIGENVALUES CORRESPONDING
C     TO THE REGULAR MATRIX PENCIL A - LAMBDA*B.
C
C     REF.:  VAN DOOREN, P., A GENERALIZED EIGENVALUE APPROACH FOR
C     SOLVING RICCATI EQUATIONS, SIAM J. SCI. STAT. COMPUT.,
C     VOL. 2, NO. 2, JUNE 1981, 121-135.
C
C     *****PARAMETER DESCRIPTION:
C
C     ON INPUT:
C
C       NMAX    INTEGER
C               ROW DIMENSION OF THE ARRAYS CONTAINING A,B,Z AS
C               DECLARED IN THE MAIN CALLING PROGRAM DIMENSION STATEMENT;
C
C       N       INTEGER
C               ORDER OF THE MATRICES A,B,Z;
C
C       A       REAL(NMAX,N)
C               UPPER HESSENBERG MATRIX WITH 1X1 OR 2X2 DIAGONAL
C               BLOCKS.  ELEMENTS OUTSIDE THE UPPER HESSENBERG
C               STRUCTURE ARE ARBITRARY;
C
C       B       REAL(NMAX,N)
C               UPPER TRIANGULAR MATRIX.  ELEMENTS OUTSIDE THE
C               UPPER TRIANGULAR STRUCTURE ARE ARBITRARY;
C
C       L       INTEGER
C               THE STARTING POSITION OF THE BLOCKS BEING INTERCHANGED;
C
C       LS1     INTEGER
C               THE SIZE OF THE FIRST BLOCK (.LE. 2);
C
C       LS2     INTEGER
C               THE SIZE OF THE SECOND BLOCK (.LE. 2);
C
C       EPS     REAL
C               REQUIRED ABSOLUTE ACCURACY OF THE RESULTS.  NORMALLY
C               EQUAL TO THE MACHINE PRECISION;
C
C     ON OUTPUT:
C
C       A,B     UPPER HESSENBERG MATRIX, UPPER TRIANGULAR MATRIX WITH
C               THE LS1 X LS1 AND LS2 X LS2 DIAGONAL BLOCKS STARTING
C               IN POSITION L INTERCHANGED;
C
C       Z       REAL(NMAX,N)
C               THIS ARRAY IS OVERWRITTEN BY THE PRODUCT OF THE
C               CONTENTS OF THE ARRAY Z(UPON ENTRY INTO THIS
C               SUBROUTINE), AND THE COLUMN TRANSFORMATIONS ZT
C               (CALCULATED BY THIS SUBROUTINE);
C
C       IFAIL   INTEGER
C               ERROR FLAG
C               = 1  INDICATES ATTEMPTED REORDERING FAILED
C               = 0  NORMAL RETURN.
C
C     *****ALGORITHM NOTES:
C     NONE
C
C     *****HISTORY:
C     WRITTEN BY P. VAN DOOREN("A GENERALIZED EIGENVALUE APPROACH
C     FOR SOLVING RICCATI EQUATIONS", INTERNAL REPORT NA-80-02,
C     DEPT. OF COMPUTER SCIENCE, STANFORD UNIVERSITY, 1980).
C
C     ----------------------------------------------------------------
C
      IFAIL = 0
      L1 = L+1
      LL = LS1+LS2
      IF (LL .GT. 2) GO TO 50
C
C     INTERCHANGE 1X1 AND 1X1 BLOCKS
C
      F = DMAX1(DABS(A(L1,L1)),DABS(B(L1,L1)))
      ALTB = .TRUE.
      IF (DABS(A(L1,L1)) .GE. F) ALTB = .FALSE.
      SA = A(L1,L1)/F
      SB = B(L1,L1)/F
      F = SA*B(L,L) - SB*A(L,L)
C
C     COMPUTE Z
C
      G = SA*B(L,L1) - SB*A(L,L1)
      CALL GIV (F,G,D,E)
      CALL ROTC (A,NMAX,N,L,L1,1,L1,D,E)
      CALL ROTC (B,NMAX,N,L,L1,1,L1,D,E)
      CALL ROTC (Z,NMAX,N,L,L1,1,N,D,E)
C
C     COMPUTE Q
C
      IF (ALTB) CALL GIV (B(L,L),B(L1,L),D,E)
      IF (.NOT. ALTB) CALL GIV (A(L,L),A(L1,L),D,E)
      CALL ROTR (A,NMAX,N,L,L1,L,N,D,E)
      CALL ROTR (B,NMAX,N,L,L1,L,N,D,E)
      A(L1,L) = 0.0D0
      B(L1,L) = 0.0D0
      RETURN
C
C     INTERCHANGE 1X1 AND 2X2 BLOCKS
C
   50 CONTINUE
      L2 = L+2
      IF (LS1 .EQ. 2) GO TO 100
      G = DMAX1(DABS(A(L,L)),DABS(B(L,L)))
      ALTB = .TRUE.
      IF (DABS(A(L,L)) .LT. G) GO TO 60
      ALTB = .FALSE.
      CALL GIV (A(L1,L1),A(L2,L1),D,E)
      CALL ROTR (A,NMAX,N,L1,L2,L1,N,D,E)
      CALL ROTR (B,NMAX,N,L1,L2,L1,N,D,E)
C
C     COMPUTE Q AND Z
C
   60 CONTINUE
      SA = A(L,L)/G
      SB = B(L,L)/G
      DO 80 J =1,2
         LJ = L+J
         DO 70 I = 1,3
            LI = L+I-1
            U(I,J) = SA*B(LI,LJ) - SB*A(LI,LJ)
   70    CONTINUE
   80 CONTINUE
      CALL GIV (U(3,1),U(3,2),D,E)
      CALL ROTC (U,3,3,1,2,1,3,D,E)
C
C     Q1
C
      CALL GIV (U(1,1),U(2,1),D,E)
      U(2,2) = -U(1,2)*E + U(2,2)*D
      CALL ROTR (A,NMAX,N,L,L1,L,N,D,E)
      CALL ROTR (B,NMAX,N,L,L1,L,N,D,E)
C
C     Z1
C
      IF (ALTB) CALL GIV (B(L1,L),B(L1,L1),D,E)
      IF (.NOT. ALTB) CALL GIV (A(L1,L),A(L1,L1),D,E)
      CALL ROTC (A,NMAX,N,L,L1,1,L2,D,E)
      CALL ROTC (B,NMAX,N,L,L1,1,L2,D,E)
      CALL ROTC (Z,NMAX,N,L,L1,1,N,D,E)
C
C     Q2
C
      CALL GIV (U(2,2),U(3,2),D,E)
      CALL ROTR (A,NMAX,N,L1,L2,L,N,D,E)
      CALL ROTR (B,NMAX,N,L1,L2,L,N,D,E)
C
C     Z2
C
      IF (ALTB) CALL GIV (B(L2,L1),B(L2,L2),D,E)
      IF (.NOT. ALTB) CALL GIV (A(L2,L1),A(L2,L2),D,E)
      CALL ROTC (A,NMAX,N,L1,L2,1,L2,D,E)
      CALL ROTC (B,NMAX,N,L1,L2,1,L2,D,E)
      CALL ROTC (Z,NMAX,N,L1,L2,1,N,D,E)
      IF (ALTB) GO TO 90
      CALL GIV (B(L,L),B(L1,L),D,E)
      CALL ROTR (A,NMAX,N,L,L1,L,N,D,E)
      CALL ROTR (B,NMAX,N,L,L1,L,N,D,E)
   90 CONTINUE
      A(L2,L) = 0.0D0
      A(L2,L1) = 0.0D0
      B(L1,L) = 0.0D0
      B(L2,L) = 0.0D0
      B(L2,L1) = 0.0D0
      RETURN
C
C     INTERCHANGE 2X2 AND 1X1 BLOCKS
C
  100 CONTINUE
      IF (LS2 .EQ. 2) GO TO 150
      G = DMAX1(DABS(A(L2,L2)),DABS(B(L2,L2)))
      ALTB = .TRUE.
      IF (DABS(A(L2,L2)) .LT. G) GO TO 120
      ALTB = .FALSE.
      CALL GIV (A(L,L),A(L1,L),D,E)
      CALL ROTR (A,NMAX,N,L,L1,L,N,D,E)
      CALL ROTR (B,NMAX,N,L,L1,L,N,D,E)
C
C     COMPUTE Q AND Z
C
  120 CONTINUE
      SA = A(L2,L2)/G
      SB = B(L2,L2)/G
      DO 130 I = 1,2
         LI = L+I-1
         DO 125 J = 1,3
            LJ = L+J-1
            U(I,J) = SA*B(LI,LJ) - SB*A(LI,LJ)
  125    CONTINUE
  130 CONTINUE
      CALL GIV (U(1,1),U(2,1),D,E)
      CALL ROTR (U,3,3,1,2,1,3,D,E)
C
C     Z1
C
      CALL GIV (U(2,2),U(2,3),D,E)
      U(1,2) = U(1,2)*E - U(1,3)*D
      CALL ROTC (A,NMAX,N,L1,L2,1,L2,D,E)
      CALL ROTC (B,NMAX,N,L1,L2,1,L2,D,E)
      CALL ROTC (Z,NMAX,N,L1,L2,1,N,D,E)
C
C     Q1
C
      IF (ALTB) CALL GIV (B(L1,L1),B(L2,L1),D,E)
      IF (.NOT. ALTB) CALL GIV (A(L1,L1),A(L2,L1),D,E)
      CALL ROTR (A,NMAX,N,L1,L2,L,N,D,E)
      CALL ROTR (B,NMAX,N,L1,L2,L,N,D,E)
C
C     Z2
C
      CALL GIV (U(1,1),U(1,2),D,E)
      CALL ROTC (A,NMAX,N,L,L1,1,L2,D,E)
      CALL ROTC (B,NMAX,N,L,L1,1,L2,D,E)
      CALL ROTC (Z,NMAX,N,L,L1,1,N,D,E)
C
C     Q2
C
      IF (ALTB) CALL GIV (B(L,L),B(L1,L),D,E)
      IF (.NOT. ALTB) CALL GIV (A(L,L),A(L1,L),D,E)
      CALL ROTR (A,NMAX,N,L,L1,L,N,D,E)
      CALL ROTR (B,NMAX,N,L,L1,L,N,D,E)
      IF (ALTB) GO TO 140
      CALL GIV (B(L1,L1),B(L2,L1),D,E)
      CALL ROTR (A,NMAX,N,L1,L2,L1,N,D,E)
      CALL ROTR (B,NMAX,N,L1,L2,L1,N,D,E)
  140 CONTINUE
      A(L1,L) = 0.0D0
      A(L2,L) = 0.0D0
      B(L1,L) = 0.0D0
      B(L2,L) = 0.0D0
      B(L2,L1) = 0.0D0
      RETURN
C
C     INTERCHANGE 2X2 AND 2X2 BLOCKS
C
  150 CONTINUE
      L3 = L+3
      AMMBMM = A(L,L)/B(L,L)
      ANMBMM = A(L1,L)/B(L,L)
      AMNBNN = A(L,L1)/B(L1,L1)
      ANNBNN = A(L1,L1)/B(L1,L1)
      BMNBNN = B(L,L1)/B(L1,L1)
      DO 180 IT1 = 1,3
         U(1,1) = 1.0D0
         U(2,1) = 1.0D0
         U(3,1) = 1.0D0
         DO 170 IT2 = 1,10
C
C     Q1, Q2
C
            CALL GIV (U(2,1),U(3,1),D,E)
            CALL ROTR (A,NMAX,N,L1,L2,L,N,D,E)
            CALL ROTR (B,NMAX,N,L1,L2,L1,N,D,E)
            U(2,1) = D*U(2,1) + E*U(3,1)
            CALL GIV (U(1,1),U(2,1),D,E)
            CALL ROTR (A,NMAX,N,L,L1,L,N,D,E)
            CALL ROTR (B,NMAX,N,L,L1,L,N,D,E)
C
C     Z1, Z2
C
            CALL GIV (B(L2,L1),B(L2,L2),D,E)
            CALL ROTC (A,NMAX,N,L1,L2,1,L3,D,E)
            CALL ROTC (B,NMAX,N,L1,L2,1,L2,D,E)
            CALL ROTC (Z,NMAX,N,L1,L2,1,N,D,E)
            CALL GIV (B(L1,L),B(L1,L1),D,E)
            CALL ROTC (A,NMAX,N,L,L1,1,L3,D,E)
            CALL ROTC (B,NMAX,N,L,L1,1,L1,D,E)
            CALL ROTC (Z,NMAX,N,L,L1,1,N,D,E)
C
C     Q3, Z3, Q4, Z4, Q5, Z5
C
            CALL GIV (A(L2,L),A(L3,L),D,E)
            CALL ROTR (A,NMAX,N,L2,L3,L,N,D,E)
            CALL ROTR (B,NMAX,N,L2,L3,L2,N,D,E)
            CALL GIV (B(L3,L2),B(L3,L3),D,E)
            CALL ROTC (A,NMAX,N,L2,L3,1,L3,D,E)
            CALL ROTC (B,NMAX,N,L2,L3,1,L3,D,E)
            CALL ROTC (Z,NMAX,N,L2,L3,1,N,D,E)
            CALL GIV (A(L1,L),A(L2,L),D,E)
            CALL ROTR (A,NMAX,N,L1,L2,L,N,D,E)
            CALL ROTR (B,NMAX,N,L1,L2,L1,N,D,E)
            CALL GIV (B(L2,L1),B(L2,L2),D,E)
            CALL ROTC (A,NMAX,N,L1,L2,1,L3,D,E)
            CALL ROTC (B,NMAX,N,L1,L2,1,L2,D,E)
            CALL ROTC (Z,NMAX,N,L1,L2,1,N,D,E)
            CALL GIV (A(L2,L1),A(L3,L1),D,E)
            CALL ROTR (A,NMAX,N,L2,L3,L1,N,D,E)
            CALL ROTR (B,NMAX,N,L2,L3,L2,N,D,E)
            CALL GIV (B(L3,L2),B(L3,L3),D,E)
            CALL ROTC (A,NMAX,N,L2,L3,1,L3,D,E)
            CALL ROTC (B,NMAX,N,L2,L3,1,L3,D,E)
            CALL ROTC (Z,NMAX,N,L2,L3,1,N,D,E)
C
C     TEST FOR CONVERGENCE
C
            IF (DABS(A(L2,L1)) .LE. EPS) GO TO 190
            A11B11 = A(L,L)/B(L,L)
            A12B22 = A(L,L1)/B(L1,L1)
            A21B11 = A(L1,L)/B(L,L)
            A22B22 = A(L1,L1)/B(L1,L1)
            B12B22 = B(L,L1)/B(L1,L1)
            U(1,1) = ((AMMBMM-A11B11)*(ANNBNN-A11B11) - AMNBNN*ANMBMM
     +               + ANMBMM*BMNBNN*A11B11)/A21B11+A12B22-
     +               A11B11*B12B22
            U(2,1) = (A22B22-A11B11)-A21B11*B12B22-(AMMBMM-A11B11)
     +               -(ANNBNN-A11B11) + ANMBMM*BMNBNN
            U(3,1) = A(L2,L1)/B(L1,L1)
  170    CONTINUE
  180 CONTINUE
      IFAIL = 1
      RETURN
  190 CONTINUE
      A(L2,L) = 0.0D0
      A(L2,L1) = 0.0D0
      A(L3,L) = 0.0D0
      A(L3,L1) = 0.0D0
      B(L1,L) = 0.0D0
      B(L2,L) = 0.0D0
      B(L2,L1) = 0.0D0
      B(L3,L) = 0.0D0
      B(L3,L1) = 0.0D0
      B(L3,L2) = 0.0D0
      RETURN
C
C     LAST LINE OF EXCHQZ
C
      END
      SUBROUTINE FBGAIN (NR,NRX,NRW,N,M,A,B,E,R,RI,S,X,FB,W,WK,IPVT,
     X                   EFLAG,RDFLG,RFLAG,SFLAG,TYPE)
C
C     *****PARAMETERS:
      INTEGER NR,NRX,NRW,N,M,IPVT(N)
      CHARACTER EFLAG,RDFLG,RFLAG,SFLAG
      DOUBLE PRECISION A(NR,N),B(NR,M),E(NR,N),R(NR,M),RI(NR,M),
     X    S(NR,M),X(NRX,N),FB(NRW,N),W(NRW,N),WK(N)
      LOGICAL TYPE
C
C     *****LOCAL VARIABLES:
      INTEGER I,J
      DOUBLE PRECISION COND 
C
C     *****FORTRAN FUNCTIONS:
C     NONE
C
C     *****SUBROUTINES CALLED:
C     MADD, MLINEQ, MMUL, MULA, MULB, TRNATA, TRNATB
C
C     --------------------------------------------------------------
C
C     *****PURPOSE:
C     GIVEN THE RICCATI SOLUTION AND THE MODEL MATRICES OF THE
C     OPTIMAL CONTROL PROBLEM, THIS SUBROUTINE CALCULATES THE
C     OPTIMAL FEEDBACK GAIN MATRIX FOR THE GENERALIZED CONTINUOUS-
C     OR DISCRETE-TIME OPTIMAL CONTROL PROBLEM.
C
C       CONTINUOUS:  FB = RI*(BT*X*E + ST)
C
C         DISCRETE:  FB = ((R + BT*X*B)**-1)*(BT*X*A + ST)
C
C     WHERE T DENOTES THE MATRIX TRANSPOSE.
C
C     REF.:  ARNOLD, W.F., "ON THE NUMERICAL SOLUTION OF
C     ALGEBRAIC MATRIX RICCATI EQUATIONS," PHD THESIS, USC,
C     DECEMBER 1983.
C
C     *****PARAMETER DESCRIPTION:
C
C     ON INPUT:
C
C       NR       INTEGER
C                ROW DIMENSION OF THE ARRAYS CONTAINING
C                A, B, E, R, RI AND S AS DECLARED IN THE MAIN
C                CALLING PROGRAM DIMENSION STATEMENT;
C
C       NRX      INTEGER
C                ROW DIMENSION OF THE ARRAY CONTAINING X AS DECLARED
C                IN THE MAIN CALLING PROGRAM DIMENSION STATEMENT;
C
C       NRW      INTEGER
C                ROW DIMENSION OF THE ARRAYS CONTAINING FB AND W AS
C                DECLARED IN THE MAIN PROGRAM DIMENSION STATEMENT;
C
C       N        INTEGER
C                ORDER OF THE SQUARE MATRICES A, E, AND X
C                ROW DIMENSION OF THE MATRICES B, S, AND FB;
C
C       M        INTEGER
C                ORDER OF THE SQUARE MATRICES R AND RI
C                COLUMN DIMENSION OF THE MATRICES B AND S;
C
C       A        REAL(NR,N)
C                MODEL SYSTEM MATRIX;
C
C       B        REAL(NR,M)
C                MODEL INPUT MATRIX;
C
C       E        REAL(NR,N)
C                MODEL DESCRIPTOR MATRIX;
C
C       R        REAL(NR,M)
C                INPUT WEIGHTING MATRIX;
C
C       RI       REAL(NR,M)
C                INVERSE OF THE INPUT WEIGHTING MATRIX;
C
C       S        REAL(NR,M)
C                STATE - INPUT CROSS-WEIGHTING MATRIX;
C
C       X        REAL(NRX,N)
C                ALGEBRAIC RICCATI EQUATION SOLUTION MATRIX;
C
C       W        REAL(NRW,N)
C                SCRATCH ARRAY OF SIZE AT LEAST N BY N;
C
C       WK       REAL(N)
C                WORKING VECTOR OF LENGTH AT LEAST N;
C
C       IPVT     INTEGER(M)
C                WORKING VECTOR OF LENGTH AT LEAST M;
C
C       EFLAG    CHARACTER
C                FLAG SET TO 'Y' IF E IS OTHER THAN THE IDENTITY
C                MATRIX;
C
C       RDFLG    CHARACTER
C                FLAG SET TO 'Y' IF R IS A DIAGONAL MATRIX;
C
C       RFLAG    CHARACTER
C                FLAG SET TO 'Y' IF R IS OTHER THAN THE IDENTITY
C                MATRIX;
C
C       SFLAG    CHARACTER
C                FLAG SET TO 'Y' IF S IS OTHER THAN THE ZERO MATRIX;
C
C       TYPE     LOGICAL
C                = .TRUE.  FOR CONTINUOUS-TIME SYSTEM
C                = .FALSE.  FOR DISCRETE-TIME SYSTEM.
C
C     ON OUTPUT:
C
C       FB       REAL(NRW,N)
C                OPTIMAL FEEDBACK GAIN MATRIX AS DESCRIBED ABOVE;
C
C       WK(1)    ESTIMATED CONDITION NUMBER OF R+BT*X*B WITH RESPECT
C                TO INVERSION (DISCRETE PROBLEM).
C
C     *****ALGORITHM NOTES:
C     NONE
C
C     *****HISTORY:
C     THIS SUBROUTINE WAS WRITTEN BY W.F. ARNOLD, NAVAL WEAPONS
C     CENTER, CODE 35104, CHINA LAKE, CA  93555, AS PART OF THE 
C     SOFTWARE PACKAGE RICPACK, SEPTEMBER 1983.
C
C     --------------------------------------------------------------
C
      IF(TYPE) GO TO 60
C
C     DISCRETE-TIME CASE
C 
      CALL TRNATB(NR,NRW,N,M,B,FB)
      CALL MULA(NRW,NRX,M,N,N,FB,X,WK)
      CALL MMUL(NRW,NR,NRW,M,M,N,FB,B,W)
      IF(RFLAG .EQ. 'Y' .OR. RFLAG .EQ. 'y') GO TO 20
      DO 10 I=1,M
          W(I,I) = W(I,I) + 1.0D0
   10 CONTINUE
      GO TO 50  
   20 CONTINUE  
      IF(RDFLG .EQ. 'Y' .OR. RDFLG .EQ. 'y') GO TO 30
      CALL MADD(NRW,NR,NRW,M,M,W,R,W)
      GO TO 50
   30 CONTINUE  
      DO 40 I=1,M
          W(I,I) = W(I,I) + R(I,I)
   40 CONTINUE
   50 CONTINUE  
      CALL MULA(NRW,NR,M,N,N,FB,A,WK)
      IF(SFLAG .NE. 'Y' .AND. SFLAG .NE. 'y') GO TO 58
      DO 54 J=1,N
          DO 52 I=1,M
              FB(I,J) = FB(I,J) + S(J,I)
   52     CONTINUE
   54 CONTINUE
   58 CONTINUE
      CALL MLINEQ(NRW,NRW,M,N,W,FB,COND,IPVT,WK)
      WK(1) = COND
      GO TO 110
   60 CONTINUE
C
C     CONTINUOUS-TIME CASE
C
      CALL TRNATB(NR,NRW,N,M,B,FB)
      CALL MULA(NRW,NRX,M,N,N,FB,X,WK)
      IF(EFLAG .EQ. 'Y' .OR. EFLAG .EQ. 'y')
     X                CALL MULA(NRW,NR,M,N,N,FB,E,WK)
      IF(SFLAG .NE. 'Y' .AND. SFLAG .NE. 'y') GO TO 68
      DO 64 J=1,N
          DO 62 I=1,M
              FB(I,J) = FB(I,J) + S(J,I)
   62     CONTINUE
   64 CONTINUE
   68 CONTINUE
      IF(RFLAG .NE. 'Y' .AND. RFLAG .NE. 'y') GO TO 100
      IF(RDFLG .NE. 'Y' .AND. RDFLG .NE. 'y') GO TO 90
      DO 80 J=1,N
          DO 70 I=1,M
              FB(I,J) = RI(I,I)*FB(I,J)
   70 CONTINUE
   80 CONTINUE  
      GO TO 100
   90 CONTINUE
      CALL MULB(NR,NRW,M,M,N,RI,FB,WK)
  100 CONTINUE
      WK(1) = 1.0D0
  110 CONTINUE
      RETURN
C
C     LAST LINE OF FBGAIN
C
      END
      SUBROUTINE GIV (A,B,D,E)
C
C     *****PARAMETERS:
      DOUBLE PRECISION A,B,D,E
C
C     *****LOCAL VARIABLES:
      DOUBLE PRECISION C
C
C     *****FORTRAN FUNCTIONS:
      DOUBLE PRECISION DABS, DMAX1
C
C     *****SUBROUTINES CALLED:
C     NONE
C
C     ----------------------------------------------------------------
C
C     *****PURPOSE:
C     THIS SUBROUTINE COMPUTES:
C
C               D = A / SQRT(A*A + B*B)
C
C               E = B / SQRT(A*A + B*B)
C
C     BY FIRST NORMALIZING BY THE LARGEST MAGNITUDE OF A OR B.
C
C     *****PARAMETER DESCRIPTION:
C
C     ON INPUT:
C
C       A       REAL;
C
C       B       REAL.
C
C     ON OUTPUT:
C
C       D       REAL
C               = A / SQRT(A*A + B*B) IF A AND B DON'T EQUAL ZERO;
C               = 1 IF A AND B EQUAL ZERO.
C
C       E       REAL
C               = B / SQRT(A*A + B*B) IF A AND B DON'T EQUAL ZERO;
C               = 0 IF A AND B EQUAL ZERO.
C
C     *****HISTORY:
C     WRITTEN BY P. VAN DOOREN("A GENERALIZED EIGENVALUE APPROACH
C     FOR SOLVING RICCATI EQUATIONS", INTERNAL REPORT NA-80-02,
C     DEPT. OF COMPUTER SCIENCE, STANFORD UNIVERSITY, 1980).
C
C     * MODIFIED 1/7/86 BY J. D. BIRDWELL, UNIVERSITY OF TENNESSEE,
C       TO DEFINE A ROTATION OF ZERO ANGLE IN CASE BOTH A AND B ARE ZERO.
C       THIS "CORRECTS" A PATHOLOGICAL CASE IN RICSOL.  NORMAL OPERATION
C       IS NOT MODIFIED.  THE MODIFICATION USES FORTRAN-77.
C
C     ----------------------------------------------------------------
C
      C = DMAX1(DABS(A),DABS(B))
      IF (C .NE. 0.D0) THEN
        D = A/C
        E = B/C
        C = DSQRT(D*D + E*E)
        D = D/C
        E = E/C
      ELSE
        D = 1.D0
        E = 0.D0
      END IF
      RETURN
C
C     LAST LINE OF GIV
C
      END
      SUBROUTINE GRADBK (N,MZ,Z,M,LOW,IGH,CPERM)
C
C     *****PARAMETERS:
      INTEGER IGH,LOW,M,MZ,N
      DOUBLE PRECISION CPERM(N),Z(MZ,N)
C
C     *****LOCAL VARIABLES:
      INTEGER I,IGHM1,II,J,K
      DOUBLE PRECISION TEMP
C
C     *****FORTRAN FUNCTIONS:
C     NONE
C
C     *****SUBROUTINES CALLED:
C     NONE
C
C     ---------------------------------------------------------------
C
C     *****PURPOSE:
C     THIS SUBROUTINE BACK TRANSFORMS THE EIGENVECTORS OF A
C     GENERALIZED EIGENVALUE PROBLEM A*X = (LAMBDA)*B*X GRADED BY
C     THE SUBROUTINE GRADEQ TO THOSE OF THE EIGENPROBLEM BEFORE
C     GRADEQ WAS APPLIED.
C
C     REF.:  WARD, R. C., BALANCING THE GENERALIZED EIGENVALUE
C     PROBLEM, SIAM J. SCI. STAT. COMPUT., VOL. 2, NO. 2, JUNE 1981,
C     141-152.
C
C     *****PARAMETER DESCRIPTION:
C
C     ON INPUT:
C
C       MZ      INTEGER
C               ROW DIMENSION OF THE ARRAY Z AS SPECIFIED IN THE MAIN
C               CALLING PROGRAM DIMENSION STATEMENT;
C
C       N       INTEGER
C               ORDER OF THE MATRICES A AND B IN THE EIGENPROBLEM;
C
C       M       INTEGER
C               SPECIFIES THE NUMBER OF EIGENVECTORS TO BE TRANS-
C               FORMED;
C
C       Z       REAL(MZ,N)
C               CONTAINS THE EIGENVECTORS TO BE TRANSFORMED;
C
C       LOW     INTEGER
C               SPECIFIES THE BEGINNING INDEX OF THE SUBMATRICES OF
C               A AND B WHICH WERE GRADED;
C
C       IGH     INTEGER
C               SPECIFIES THE ENDING INDEX OF THE SUBMATRICES OF
C               A AND B WHICH WERE GRADED;
C
C       CPERM   REAL(N)
C               CONTAINS IN ITS LOW THROUGH IGH LOCATIONS THE COLUMN
C               PERMUTATIONS APPLIED IN GRADING THE A AND B
C               SUBMATRICES.
C
C     ON OUTPUT:
C
C       Z       CONTAINS THE TRANSFORMED EIGENVECTORS.
C
C     *****ALGORITHM NOTES:
C     NONE.
C
C     *****HISTORY:
C     WRITTEN BY R. C. WARD.......
C
C     ---------------------------------------------------------------
C
      IF (LOW .EQ. IGH) GO TO 530
      IGHM1 = IGH-1
      DO 520 II = LOW,IGHM1
         I = IGHM1 + LOW - II
         K = CPERM(I)
         IF (K .EQ. I) GO TO 520
         DO 510 J = 1,M
            TEMP = Z(I,J)
            Z(I,J) = Z(K,J)
            Z(K,J) = TEMP
  510    CONTINUE
  520 CONTINUE
  530 CONTINUE
      RETURN
C
C     LAST LINE OF GRADBK
C
      END
      SUBROUTINE GRADEQ (N,MA,A,MB,B,LOW,IGH,CPERM,WK)
C
C     *****PARAMETERS:
      INTEGER IGH,LOW,MA,MB,N
      DOUBLE PRECISION A(MA,N),B(MB,N),CPERM(N),WK(N,2)
C
C     *****LOCAL VARIABLES:
      INTEGER I,IGHM1,IM,IP1,J,JM,JP1,K
      DOUBLE PRECISION CMAX,RMAX,SUMA,SUMB,TEMP
C
C     *****FORTRAN FUNCTIONS:
      DOUBLE PRECISION DABS
C
C     *****SUBROUTINES CALLED:
C     NONE
C
C     ---------------------------------------------------------------
C
C     *****PURPOSE:
C     THIS SUBROUTINE GRADES THE SUBMATRICES OF A AND B GIVEN BY
C     STARTING INDEX LOW AND ENDING INDEX IGH IN THE GENERALIZED
C     EIGENVALUE PROBLEM A*X = (LAMBDA)*B*X BY PERMUTING ROWS AND
C     COLUMNS SUCH THAT THE NORM OF THE I-TH ROW (COLUMN) OF THE
C     A SUBMATRIX DIVIDED BY THE NORM OF THE I-TH ROW (COLUMN) OF
C     THE B SUBMATRIX BECOMES SMALLER AS I INCREASES.
C     REF.:  WARD, R. C., BALANCING THE GENERALIZED EIGENVALUE
C     PROBLEM, SIAM J. SCI. STAT. COMPUT., VOL. 2, NO. 2, JUNE 1981,
C     141-152.
C
C     *****PARAMETER DESCRIPTION:
C
C     ON INPUT:
C
C       MA,MB   INTEGER
C               ROW DIMENSIONS OF THE ARRAYS CONTAINING MATRICES
C               A AND B RESPECTIVELY, AS DECLARED IN THE MAIN CALLING
C               PROGRAM DIMENSION STATEMENT;
C
C       N       INTEGER
C               ORDER OF THE MATRICES A AND B;
C
C       A       REAL(MA,N)
C               CONTAINS THE A MATRIX OF THE GENERALIZED EIGENPROBLEM
C               DEFINED ABOVE;
C
C       B       REAL(MB,N)
C               CONTAINS THE B MATRIX OF THE GENERALIZED EIGENPROBLEM
C               DEFINED ABOVE;
C
C       LOW     INTEGER
C               SPECIFIES THE BEGINNING INDEX FOR THE ROWS AND
C               COLUMNS OF A AND B TO BE GRADED;
C
C       IGH     INTEGER
C               SPECIFIES THE ENDING INDEX FOR THE ROWS AND COLUMNS
C               OF A AND B TO BE GRADED;
C
C       WK      REAL(N,2)
C               WORK ARRAY THAT MUST CONTAIN AT LEAST 2*N LOCATIONS.
C               ONLY LOCATIONS LOW THROUGH IGH AND N+LOW THROUGH
C               N+IGH ARE REFERENCED BY THIS SUBROUTINE.
C
C     ON OUTPUT:
C
C       A,B     CONTAIN THE PERMUTED AND GRADED A AND B MATRICES;
C
C       CPERM   REAL(N)
C               CONTAINS IN ITS LOW THROUGH IGH LOCATIONS THE
C               COLUMN PERMUTATIONS APPLIED IN GRADING THE
C               SUBMATRICES.  THE OTHER LOCATIONS ARE NOT REFERENCED
C               BY THIS SUBROUTINE;
C
C       WK      CONTAINS IN ITS LOW THROUGH IGH LOCATIONS THE ROW
C               PERMUTATIONS APPLIED IN GRADING THE SUBMATRICES.
C
C     *****ALGORITHM NOTES:
C     NONE.
C
C     *****HISTORY:
C     WRITTEN BY R. C. WARD.......
C
C     ---------------------------------------------------------------
C
      IF (LOW .EQ. IGH) GO TO 510
      IGHM1 = IGH-1
C
C     COMPUTE COLUMN NORMS OF A / THOSE OF B
C
      DO 420 J = LOW,IGH
         SUMA = 0.0D0
         SUMB = 0.0D0
         DO 410 I = LOW,IGH
            SUMA = SUMA + DABS(A(I,J))
            SUMB = SUMB + DABS(B(I,J))
  410    CONTINUE
         IF (SUMB .EQ. 0.0D0) GO TO 415
         WK(J,2) = SUMA / SUMB
         GO TO 420
  415    CONTINUE
         WK(J,2) = 1.0D38
  420 CONTINUE
C
C     PERMUTE COLUMNS TO ORDER THEM BY DECREASING QUOTIENTS
C
      DO 450 J = LOW,IGHM1
         CMAX = WK(J,2)
         JM = J
         JP1 = J+1
         DO 430 K = JP1,IGH
            IF (CMAX .GE. WK(K,2)) GO TO 430
            JM = K
            CMAX = WK(K,2)
  430    CONTINUE
         CPERM(J) = JM
         IF (JM .EQ. J) GO TO 450
         TEMP = WK(J,2)
         WK(J,2) = WK(JM,2)
         WK(JM,2) = TEMP
         DO 440 I = 1,IGH
            TEMP = B(I,J)
            B(I,J) = B(I,JM)
            B(I,JM) = TEMP
            TEMP = A(I,J)
            A(I,J) = A(I,JM)
            A(I,JM) = TEMP
  440    CONTINUE
  450 CONTINUE
      CPERM(IGH) = IGH
C
C     COMPUTE ROW NORMS OF A / THOSE OF B
C
      DO 470 I = LOW,IGH
         SUMA = 0.0D0
         SUMB = 0.0D0
         DO 460 J = LOW,IGH
            SUMA = SUMA + DABS(A(I,J))
            SUMB = SUMB + DABS(B(I,J))
  460    CONTINUE
         IF (SUMB .EQ. 0.0D0) GO TO 465
         WK(I,2) = SUMA / SUMB
         GO TO 470
  465    CONTINUE
         WK(I,2) = 1.0D38
C
C     PERMUTE ROWS TO ORDER THEM BY DECREASING QUOTIENTS
C
  470 CONTINUE
      DO 500 I = LOW,IGHM1
         RMAX = WK(I,2)
         IM = I
         IP1 = I+1
         DO 480 K = IP1,IGH
            IF (RMAX .GE. WK(K,2)) GO TO 480
            IM = K
            RMAX = WK(K,2)
  480    CONTINUE
         WK(I,1) = IM
         IF (IM .EQ. I) GO TO 500
         TEMP = WK(I,2)
         WK(I,2) = WK(IM,2)
         WK(IM,2) = TEMP
         DO 490 J = LOW,N
            TEMP = B(I,J)
            B(I,J) = B(IM,J)
            B(IM,J) = TEMP
            TEMP = A(I,J)
            A(I,J) = A(IM,J)
            A(IM,J) = TEMP
  490    CONTINUE
  500 CONTINUE
      WK(IGH,1) = IGH
  510 CONTINUE
      RETURN
C
C     LAST LINE OF GRADEQ
C
      END
      SUBROUTINE MADD (NA,NB,NC,M,N,A,B,C)
C
C     *****PARAMETERS:
      INTEGER NA,NB,NC,M,N
      DOUBLE PRECISION A(NA,N),B(NB,N),C(NC,N)
C
C     *****LOCAL VARIABLES:
      INTEGER I,J
C
C     *****SUBROUTINES CALLED:
C     NONE
C
C     ------------------------------------------------------------------
C
C     *****PURPOSE:
C     THIS SUBROUTINE COMPUTES THE MATRIX SUM A+B AND STORES THE
C     RESULT IN THE ARRAY C.  ALL MATRICES ARE M X N.  THE SUM
C     MAY BE OVERWRITTEN INTO A (B) BY DESIGNATING THE ARRAY C
C     TO BE A (B).
C
C     *****PARAMETER DESCRIPTION:
C     ON INPUT:
C        NA,NB,NC         ROW DIMENSIONS OF THE ARRAYS CONTAINING A,B,
C                         AND C,RESPECTIVELY, AS DECLARED IN THE CALLING
C                         PROGRAM DIMENSION STATEMENT;
C
C        M                NUMBER OF ROWS OF THE MATRICES A, B, AND C;
C
C        N                NUMBER OF COLUMNS OF THE MATRICES A, B, AND C;
C
C        A                AN M X N MATRIX;
C
C        B                AN M X N MATRIX.
C
C     ON OUTPUT:
C
C        C                AN M X N ARRAY CONTAINING A+B.
C
C     *****HISTORY:
C     WRITTEN BY ALAN J. LAUB (ELEC. SYS. LAB., M.I.T., RM. 35-331,
C     CAMBRIDGE, MA 02139,  PH.: (617)-253-2125), SEPTEMBER 1977.
C     MOST RECENT VERSION: SEP. 21, 1977.
C
C     ------------------------------------------------------------------
C
      DO 20 J=1,N
         DO 10 I=1,M
            C(I,J)=A(I,J)+B(I,J)
10       CONTINUE
20    CONTINUE
      RETURN
C
C     LAST LINE OF MADD
C
      END
      SUBROUTINE MLINEQ (NA,NB,N,M,A,B,COND,IPVT,WORK)
C
C     *****PARAMETERS:
      INTEGER NA,NB,N,M,IPVT(N)
      DOUBLE PRECISION A(NA,N),B(NB,M),COND,WORK(N)
C
C     *****LOCAL VARIABLES:
      INTEGER J
C
C     *****SUBROUTINES CALLED:
C     DGECOM,DGESLM
C
C     ------------------------------------------------------------------
C
C     *****PURPOSE:
C     THIS SUBROUTINE SOLVES THE MATRIX LINEAR EQUATION
C                             A*X = B
C     WHERE A IS AN N X N (INVERTIBLE) MATRIX AND B IS AN N X M
C     MATRIX.  SUBROUTINE DGECOM IS CALLED ONCE FOR THE LU-FACTOR-
C     IZATION OF A AND SUBROUTINE DGESLM IS CALLED M TIMES FOR
C     FORWARD ELIMINATION AND BACK SUBSTITUTION TO PRODUCE THE
C     M COLUMNS OF THE SOLUTION MATRIX X = (A-INVERSE)*B.  AN
C     ESTIMATE OF THE CONDITION OF A IS RETURNED.  SHOULD A BE
C     SINGULAR TO WORKING ACCURACY, COND IS SET TO 1.0D+20.
C
C     *****PARAMETER DESCRIPTION:
C
C     ON INPUT:
C
C        NA,NB            ROW DIMENSIONS OF THE ARRAYS CONTAINING A AND
C                         B, RESPECTIVELY, AS DECLARED IN THE CALLING
C                         PROGRAM DIMENSION STATEMENT;
C
C        N                ORDER OF THE MATRIX A AND NUMBER OF ROWS OF
C                         THE MATRIX B;
C
C        M                NUMBER OF COLUMNS OF THE MATRIX B;
C
C        A                N X N COEFFICIENT MATRIX;
C
C        B                N X M RIGHT HAND SIDE MATRIX.
C
C     ON OUTPUT:
C
C        B                SOLUTION MATRIX  X = (A-INVERSE)*B;
C
C        COND             AN ESTIMATE OF THE CONDITION OF A.
C                         = 1/RCOND  WHERE RCOND IS THE INVERSE
C                         OF THE CONDITION ESTIMATE (SEE THE LINPACK
C                         USER'S GUIDE FOR DETAILS);
C
C        IPVT             PIVOT VECTOR OF LENGTH N (SEE DGECOM
C                         DOCUMENTATION);
C
C        WORK             A REAL SCRATCH VECTOR OF LENGTH N.
C
C     *****APPLICATIONS AND USAGE RESTRICTIONS:
C     (1)THE VALUE OF COND SHOULD ALWAYS BE CHECKED BY THE CALLING
C        PROGRAM.  SHOULD A BE NEAR-SINGULAR (OR SINGULAR TO WORKING
C        ACCURACY) THE DATA SHOULD BE INVESTIGATED FOR POSSIBLE
C        ERRORS.  IF THERE ARE NONE AND THE PROBLEM IS APPARENTLY
C        WELL-POSED AND/OR MEANINGFUL, SINGULAR VALUE ANALYSIS MAY
C        THEN BE A MORE RELIABLE SOLUTION TECHNIQUE (E.G., EISPACK
C        SUBROUTINES  SVD  AND  MINFIT).
C     (2)MLINEQ CAN BE USED TO COMPUTE THE INVERSE OF A:  SIMPLY SOLVE
C        A*X = I WHERE  I  IS THE N X N IDENTITY MATRIX.
C     (3)IF THE SOLUTION TO X*A = B  (X = B*(A-INVERSE)) IS DESIRED,
C        SIMPLY TRANSPOSE THE SOLUTION OF
C         T      T
C        A *X = B .
C
C     *****ALGORITHM NOTES:
C     THE CONTENTS OF A ARE MODIFIED BY THIS SUBROUTINE.  SHOULD THE
C     ORIGINAL COEFFICIENTS OF A BE NEEDED SUBSEQUENTLY, THE
C     CONTENTS OF A SHOULD BE SAVED PRIOR TO THE CALL TO MLINEQ.
C
C     *****HISTORY:
C     WRITTEN BY ALAN J. LAUB (DEP'T. OF ELEC. ENGRG. - SYSTEMS,
C     UNIVERSITY OF SOUTHERN CALIFORNIA, LOS ANGELES, CA 90007,
C     PH.: (213)-743-5535), MAY 1980.
C     MOST RECENT VERSION:  MAY 6, 1980.
C
C     ------------------------------------------------------------------
C
      CALL DGECOM (A,NA,N,IPVT,COND,WORK)
      IF ((1.0D0 + COND) .GT. 1.0D0) GO TO 20
      COND = 1.0D+20
      RETURN
   20 CONTINUE
      COND = 1.0D0/COND
      DO 30 J=1,M
C
C        COMPUTE  (J-TH COLUMN OF X) = (A-INVERSE)*(J-TH COLUMN OF B)
C
         CALL DGESLM (A,NA,N,IPVT,B(1,J))
   30 CONTINUE
      RETURN
      END
      SUBROUTINE MMUL (NA,NB,NC,L,M,N,A,B,C)
C
C     *****PARAMETERS:
      INTEGER NA,NB,NC,L,M,N
      DOUBLE PRECISION A(NA,N),B(NB,L),C(NC,L)
C
C     *****LOCAL VARIABLES:
      INTEGER I,J,K
C
C     *****SUBROUTINES CALLED:
C     NONE
C
C     ------------------------------------------------------------------
C
C     *****PURPOSE:
C     THIS SUBROUTINE COMPUTES THE MATRIX PRODUCT A*B AND STORES THE
C        RESULT IN THE ARRAY C.  A IS M X N, B IS N X L, AND C IS
C        M X L.  THE ARRAY C MUST BE DISTINCT FROM BOTH A AND B.
C
C     *****PARAMETER DESCRIPTION:
C     ON INPUT:
C        NA    ROW DIMENSION OF THE ARRAY CONTAINING A AS DECLARED
C              IN THE CALLING PROGRAM DIMENSION STATEMENT;
C
C        NB    ROW DIMENSION OF THE ARRAY CONTAINING B AS DECLARED
C              IN THE CALLING PROGRAM DIMENSION STATEMENT;
C
C        NC    ROW DIMENSION OF THE ARRAY CONTAINING C AS DECLARED
C              IN THE CALLING PROGRAM DIMENSION STATEMENT;
C
C        L     NUMBER OF COLUMNS OF THE MATRICES B AND C;
C
C        M     NUMBER OF ROWS OF THE MATRICES A AND C;
C
C        N     NUMBER OF COLUMNS OF THE MATRIX A AND NUMBER OF ROWS
C              OF THE MATRIX B;
C
C        A     AN M X N MATRIX;
C
C        B     AN N X L MATRIX.
C
C     ON OUTPUT:
C
C        C     AN M X L ARRAY CONTAINING A*B.
C
C     *****HISTORY:
C     WRITTEN BY ALAN J. LAUB (ELEC. SYS. LAB., M.I.T., RM. 35-331,
C     CAMBRIDGE, MA 02139,  PH.: (617)-253-2125), SEPTEMBER 1977.
C     MOST RECENT VERSION: SEP. 21, 1977.
C
C     ------------------------------------------------------------------
C
      DO 40 J=1,L
         DO 10 I=1,M
            C(I,J)=0.0D0
10       CONTINUE
         DO 30 K=1,N
            DO 20 I=1,M
               C(I,J)=C(I,J)+A(I,K)*B(K,J)
20          CONTINUE
30       CONTINUE
40    CONTINUE
      RETURN
C
C     LAST CARD OF MMUL
C
      END
      SUBROUTINE MULA(NA,NB,N,M,L,A,B,WORK)
C
C     *****PARAMETERS:
      INTEGER NA,NB,N,M,L
      DOUBLE PRECISION A(NA,M),B(NB,L),WORK(L)
C
C     *****LOCAL VARIABLES:
      INTEGER I,J,K
C
C     *****FORTRAN FUNCTIONS:
C     NONE.
C
C     *****SUBROUTINES CALLED:
C     NONE.
C
C     ------------------------------------------------------------------
C
C     *****PURPOSE:
C     THIS SUBROUTINE COMPUTES THE MATRIX PRODUCT A * B AND OVERWRITES
C     IT INTO THE ARRAY A.  WHERE A IS N BY M AND B IS M BY L AND M IS
C     GREATER THAN OR EQUAL TO L.
C
C     *****PARAMETER DESCRIPTION:
C
C     ON INPUT:
C
C       NA,NB   INTEGER
C               ROW DIMENSIONS OF THE ARRAYS CONTAINING A AND B,
C               RESPECTIVELY, AS DECLARED IN THE MAIN CALLING PROGRAM
C               DIMENSION STATEMENT;
C
C       N       INTEGER
C               ROW DIMENSION OF THE MATRIX A;
C
C       M       INTEGER
C               COLUMN DIMENSION OF THE MATRIX A AND ROW DIMENSION OF
C               THE MATRIX B;
C
C       L       INTEGER
C               COLUMN DIMENSION OF THE MATRIX B;
C
C       A       REAL(NA,M)
C               AN N BY M MATRIX;
C
C       B       REAL(NB,L)
C               AN M BY L MATRIX.
C
C     ON OUTPUT:
C
C       A       CONTAINS THE N BY L MATRIX PRODUCT A * B.
C
C     *****ALGORITHM NOTES:
C     NONE.
C
C     *****HISTORY:
C     THIS SUBROUTINE WAS WRITTEN BY W.F. ARNOLD, NAVAL WEAPONS CENTER,
C     CODE 35104, CHINA LAKE, CA  93555, AS PART OF THE SOFTWARE PACKAGE
C     RICPACK, SEPTEMBER 1983.
C
C     ------------------------------------------------------------------
C
      DO 40 I=1,N
          DO 20 J=1,L
              WORK(J) = 0.0D0
              DO 10 K=1,M
                  WORK(J) = WORK(J) + A(I,K)*B(K,J)
   10         CONTINUE
   20     CONTINUE
          DO 30 J=1,L
              A(I,J) = WORK(J)
   30     CONTINUE
   40 CONTINUE
      RETURN
C
C     LAST LINE OF MULA
C
      END
      SUBROUTINE MULB(NA,NB,N,M,L,A,B,WORK)
C
C     PARAMETERS:
      INTEGER NA,NB,N,M,L
      DOUBLE PRECISION A(NA,M),B(NB,L),WORK(N)
C
C     *****LOCAL VARIABLES:
      INTEGER I,J,K
C
C     *****FORTRAN FUNCTIONS:
C     NONE.
C
C     *****SUBROUTINES CALLED:
C     NONE.
C
C     ------------------------------------------------------------------
C
C     *****PURPOSE:
C     THIS SUBROUTINE COMPUTES THE MATRIX PRODUCT A * B AND OVERWRITES
C     IT INTO THE ARRAY B.  WHERE A IS N BY M AND B IS M BY L AND NB IS
C     GREATER THAN OR EQUAL TO N.
C
C     *****PARAMETER DESCRIPTION:
C
C     ON INPUT:
C
C       NA,NB   INTEGER
C               ROW DIMENSIONS OF THE ARRAYS CONTAINING A AND B,
C               RESPECTIVELY, AS DECLARED IN THE MAIN CALLING PROGRAM
C               DIMENSION STATEMENT;
C
C       N       INTEGER
C               ROW DIMENSION OF THE MATRIX A;
C
C       M       INTEGER
C               COLUMN DIMENSION OF THE MATRIX A AND ROW DIMENSION OF
C               THE MATRIX B;
C
C       L       INTEGER
C               COLUMN DIMENSION OF THE MATRIX B;
C
C       A       REAL(NA,M)
C               AN N BY M MATRIX;
C
C       B       REAL(NB,L)
C               AN M BY L MATRIX.
C
C     ON OUTPUT:
C
C       B       CONTAINS THE N BY L MATRIX PRODUCT A * B.
C
C     *****ALGORITHM NOTES:
C     NONE.
C
C     *****HISTORY:
C     THIS SUBROUTINE WAS WRITTEN BY W.F. ARNOLD, NAVAL WEAPONS CENTER,
C     CODE 35104, CHINA LAKE, CA  93555, AS PART OF THE SOFTWARE PACKAGE
C     RICPACK, SEPTEMBER 1983.
C
C     ------------------------------------------------------------------
C
      DO 50 J=1,L
          DO 10 I=1,N
              WORK(I) = 0.0D0
   10     CONTINUE
          DO 30 K=1,M
              DO 20 I=1,N
                  WORK(I) = WORK(I) + A(I,K)*B(K,J)
   20         CONTINUE
   30     CONTINUE
          DO 40 I=1,N
              B(I,J) = WORK(I)
   40     CONTINUE
   50 CONTINUE
      RETURN
C
C     LAST LINE OF MULB
C
      END
      SUBROUTINE ORDER (A,B,Z,NMAX,N,EPS,IFAIL,TYPE,IFIRST,IND)
C
C     *****PARAMETERS:
      INTEGER IFAIL,IFIRST,N,NMAX,IND(N)
      DOUBLE PRECISION EPS,A(NMAX,N),B(NMAX,N),Z(NMAX,N)
      LOGICAL TYPE
C
C     *****LOCAL VARIABLES:
      INTEGER I,II,III,IS,ISTEP,K,L,LS,LS1,LS2,L1,L2,NUM
C     DOUBLE PRECISION EPS2
C
C     *****FORTRAN FUNCTIONS:
      DOUBLE PRECISION DABS
C
C     *****SUBROUTINES CALLED:
C     EXCHQZ
C
C     ---------------------------------------------------------------
C
C     *****PURPOSE:
C     GIVEN THE UPPER TRIANGULAR MATRIX B AND UPPER HESSENBERG
C     MATRIX A WITH 1X1 OR 2X2 DIAGONAL BLOCKS, THIS SUBROUTINE
C     REORDERS THE DIAGONAL BLOCKS ALONG WITH THE GENERALIZED
C     EIGENVALUES CORRESPONDING TO THE REGULAR MATRIX PENCIL
C     A - LAMBDA*B  BY CONSTRUCTING ROW AND COLUMN EQUIVALENCE
C     TRANSFORMATIONS QT AND ZT.  THE COLUMN TRANSFORMATIONS ARE
C     THEN APPLIED TO THE MATRIX Z.
C
C     REF.:  VAN DOOREN, P., A GENERALIZED EIGENVALUE APPROACH FOR
C     SOLVING RICCATI EQUATIONS, SIAM J. SCI. STAT. COMPUT.,
C     VOL. 2, NO. 2, JUNE 1981, 121-135.
C
C     *****PARAMETER DESCRIPTION:
C
C     ON INPUT:
C
C       NMAX    INTEGER
C               ROW DIMENSION OF THE ARRAYS CONTAINING A,B,Z AS
C               DECLARED IN THE MAIN CALLING PROGRAM DIMENSION STATEMENT;
C
C       N       INTEGER
C               ORDER OF THE MATRICES A,B,Z;
C
C       A       REAL(NMAX,N)
C               UPPER HESSENBERG MATRIX WITH 1X1 OR 2X2 DIAGONAL
C               BLOCKS.  ELEMENTS OUTSIDE THE UPPER HESSENBERG
C               STRUCTURE ARE ARBITRARY;
C
C       B       REAL(NMAX,N)
C               UPPER TRIANGULAR MATRIX.  ELEMENTS OUTSIDE THE
C               UPPER TRIANGULAR STRUCTURE ARE ARBITRARY;
C
C       EPS     REAL
C               REQUIRED ABSOLUTE ACCURACY OF THE RESULTS.  NORMALLY
C               EQUAL TO THE MACHINE PRECISION;
C
C       TYPE    LOGICAL
C               CONTROL PARAMETER THAT SPECIFIES THE REGIONS OF THE
C               THE COMPLEX PLANE THAT THE GENERALIZED EIGENVALUES
C               ARE ORDERED BY.  TO CONTROL THE REGION THAT APPEARS
C               FIRST, SEE IFIRST BELOW
C               = .TRUE.  GENERALIZED EIGENVALUES ARE ORDERED BY
C                    REGION INSIDE THE COMPLEX LEFT HALF PLANE OR
C                    OUTSIDE THIS REGION
C               = .FALSE.  GENERALIZED EIGENVALUES ORDERED BY REGION
C                    INSIDE THE UNIT CIRCLE OR OUTSIDE THIS REGION;
C
C       IFIRST  INTEGER
C               CONTROL PARAMETER THAT SPECIFIES WHICH OF THE REGIONS
C               SPECIFIED BY TYPE(SEE ABOVE) APPEARS FIRST(I.E. IN THE
C               UPPER LEFT NXN BLOCK)
C               = -1  INSIDE REGION APPEARS FIRST
C               = +1  OUTSIDE REGION APPEARS FIRST
C               IFIRST IS ALTERED BY THIS SUBROUTINE;
C
C       IND     INTEGER(N)
C               WORKING ARRAY THAT IS ALTERED BY THIS SUBROUTINE.
C
C     ON OUTPUT:
C
C       A,B     UPPER HESSENBERG MATRIX, UPPER TRIANGULAR MATRIX
C               REORDERED AS SPECIFIED BY TYPE AND IFIRST(SEE ABOVE);
C
C       Z       REAL(NMAX,N)
C               THIS ARRAY IS OVERWRITTEN BY THE PRODUCT OF THE
C               CONTENTS OF THE ARRAY Z(UPON ENTRY INTO THIS
C               SUBROUTINE), AND THE COLUMN TRANSFORMATIONS ZT
C               (CALCULATED BY THIS SUBROUTINE);
C
C       IFAIL   INTEGER
C               ERROR FLAG
C               = 1  INDICATES ATTEMPTED REORDERING FAILED
C               = 0  NORMAL RETURN.
C
C     *****ALGORITHM NOTES:
C     NONE
C
C     *****HISTORY:
C     ORIGINAL VERSION THAT SORTED BY UNIT CIRCLE REGION OF COMPLEX
C     PLANE WRITTEN BY P. VAN DOOREN("A GENERALIZED EIGENVALUE
C     APPROACH FOR SOLVING RICCATI EQUATIONS", INTERNAL REPORT
C     NA-80-02, DEPT. OF COMPUTER SCIENCE, STANFORD UNIVERSITY,
C     1980).  THIS VERSION MODIFIED BY W. F. ARNOLD(DEPT. OF
C     ELECTRICAL ENGINEERING - SYSTEMS, UNIV. OF SOUTHERN CALIF.,
C     LOS ANGELES, CA  90089) TO INCLUDE THE SORTING CONTROL PARAMETER
C     "TYPE", SEPT 1982.
C
C     ----------------------------------------------------------------
C
      IFAIL = 1
      NUM = 0
      L = 0
      LS = 1
C
C--JDB/CASCADE: PATCH TO MAKE ALGORITHM LESS SENSITIVE TO INEXACT ZEROS, 7/2/87
C
C     EPS2 = SQRT(EPS)
C
C     DETERMINE SIZE AND REGION LOCATION OF BLOCKS
C
   10 CONTINUE
      L = L+LS
      IF (L .GT. N) GO TO 50
      IS = -IFIRST
      L1 = L+1
      IF (L1 .GT. N) GO TO 20
C--JDB/CASCADE: REPLACED FOLLOWING LINE 6/16/87
      IF (A(L1,L) .EQ. 0.0D0) GO TO 20
C     IF (A(L1,L) .LE. EPS2*DMAX1(DABS(A(L,L)),DABS(A(L1,L1)))) GO TO 20
C
C     2X2 BLOCK
C
      LS = 2
      IF (.NOT. TYPE) GO TO 15
      IF ((A(L,L)*B(L1,L1)+A(L1,L1)*B(L,L)-A(L1,L)*B(L,L1))/
     X    (B(L,L)*B(L1,L1)) .LT. 0.0D0) IS = IFIRST
      GO TO 30
   15 CONTINUE
      IF (DABS(A(L,L)*A(L1,L1)-A(L1,L)*A(L,L1)) .LT.
     +    DABS(B(L,L)*B(L1,L1))) IS= IFIRST
      GO TO 30
C
C     1X1 BLOCK
C
   20 CONTINUE
      LS = 1
      IF (.NOT. TYPE) GO TO 25
      IF (A(L,L)*B(L,L) .LT. 0.0D0) IS = IFIRST
      IF (A(L,L) .LT. 0.0D0 .AND. B(L,L) .EQ. 0.0D0) IS = IFIRST
      GO TO 30
   25 CONTINUE
      IF (DABS(A(L,L)) .LT. DABS(B(L,L))) IS = IFIRST
   30 CONTINUE
      NUM = NUM+1
      IND(NUM) = LS*IS
      GO TO 10
C
C     REORDER BLOCKS
C
   50 CONTINUE
      L2 = 1
      I = 0
   60 CONTINUE
      I = I+1
      IF (IND(I) .GT. 0) GO TO 70
      L2 = L2-IND(I)
      GO TO 60
   70 CONTINUE
      K = I
   80 CONTINUE
      L2 = L2+IND(K)
   85 CONTINUE
      K = K+1
      IF (K .GT. NUM) GO TO 100
      IF (IND(K) .GT. 0) GO TO 80
C
C     INTERCHANGE BLOCK K BEFORE BLOCK I
C
      ISTEP = K-I
      LS2 = -IND(K)
      L = L2
      DO 90 II = 1,ISTEP
         III = K-II
         LS1 = IND(III)
         L = L-LS1
         CALL EXCHQZ (A,B,Z,NMAX,N,L,LS1,LS2,EPS,IFAIL)
         IF (IFAIL .EQ. 1) RETURN
         IND(III+1) = IND(III)
   90 CONTINUE
      IND(I) = -LS2
      I = I+1
      L2 = L2+LS2
      GO TO 85
  100 CONTINUE
      IFAIL = 0
      RETURN
C
C     LAST LINE OF ORDER
C
      END
      SUBROUTINE QZHESW(NM,N,A,B,LOW,IGH,MATZ,Z)
C
      INTEGER I,J,K,L,N,LB,L1,NM,NK1,LOW,IGH,IGHM1,IGHM2
      DOUBLE PRECISION A(NM,N),B(NM,N),Z(NM,N)
      DOUBLE PRECISION R,S,T,U1,U2,V1,V2,RHO
      DOUBLE PRECISION DSQRT,DABS,DSIGN
      LOGICAL MATZ
C
C     THIS SUBROUTINE IS THE FIRST STEP OF THE QZ ALGORITHM
C     FOR SOLVING GENERALIZED MATRIX EIGENVALUE PROBLEMS,
C     SIAM J. NUMER. ANAL. 10, 241-256(1973) BY MOLER AND STEWART.
C     THE CODE IS A MODIFICATION OF SUBROUTINE QZHES FOUND IN EISPACK
C     SO AS TO ACCEPT PARTITIONED MATRICES AS PROVIDED BY THE
C     BALANCING ALGORITHM OF WARD IN SIAM J. SCIEN. STAT. COMPU. 2,
C     141-152 (1981).
C
C     THIS SUBROUTINE ACCEPTS A PAIR OF REAL GENERAL MATRICES AND
C     REDUCES ONE OF THEM TO UPPER HESSENBERG FORM AND THE OTHER
C     TO UPPER TRIANGULAR FORM USING ORTHOGONAL TRANSFORMATIONS.
C     IT IS USUALLY FOLLOWED BY  QZITW, QZVAL  AND, POSSIBLY,  QZVEC.
C
C     ON INPUT-
C
C        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL
C          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
C          DIMENSION STATEMENT,
C
C        N IS THE ORDER OF THE MATRICES,
C
C        A CONTAINS A REAL GENERAL MATRIX,
C
C        B CONTAINS A REAL GENERAL MATRIX,
C
C        LOW IS THE STARTING INDEX FOR THE SCALED SUBMATRICES OF
C          A AND B OBTAINED FROM THE BALANCING ALGORITHM.
C          IF THE MATRICES HAVE NOT BEEN BALANCED, SET LOW TO 1.
C
C        IGH IS THE ENDING INDEX FOR THE SCALED SUBMATRICES OF
C          A AND B OBTAINED FROM THE BALANCING ALGORITHM.
C          IF THE MATRICES HAVE NOT BEEN BALANCED, SET IGH TO N.
C
C        MATZ SHOULD BE SET TO .TRUE. IF THE RIGHT HAND TRANSFORMATIONS
C          ARE TO BE ACCUMULATED FOR LATER USE IN COMPUTING
C          EIGENVECTORS, AND TO .FALSE. OTHERWISE.
C
C     ON OUTPUT-
C
C        A HAS BEEN REDUCED TO UPPER HESSENBERG FORM.  THE ELEMENTS
C          BELOW THE FIRST SUBDIAGONAL HAVE BEEN SET TO ZERO,
C
C        B HAS BEEN REDUCED TO UPPER TRIANGULAR FORM.  THE ELEMENTS
C          BELOW THE MAIN DIAGONAL HAVE BEEN SET TO ZERO,
C
C        Z CONTAINS THE PRODUCT OF THE RIGHT HAND TRANSFORMATIONS IF
C          MATZ HAS BEEN SET TO .TRUE.  OTHERWISE, Z IS NOT REFERENCED.
C
C     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO R. C. WARD,
C     UNION CARBIDE CORP.-NUCLEAR DIVISION, P.O. BOX Y, BLDG.
C     9704-1, OAK RIDGE, TENNESSEE 37830.
C
C     ------------------------------------------------------------------
C
C     ********** INITIALIZE Z **********
      IF (.NOT. MATZ) GO TO 10
C
      DO 3 I = 1, N
C
         DO 2 J = 1, N
            Z(I,J) = 0.0D0
    2    CONTINUE
C
         Z(I,I) = 1.0D0
    3 CONTINUE
C     ********** REDUCE B TO UPPER TRIANGULAR FORM **********
   10 IF (LOW .EQ. IGH) GO TO 170
      IGHM1 = IGH-1
C
      DO 100 L =LOW, IGHM1
         L1 = L + 1
         S = 0.0D0
C
         DO 20 I = L1, IGH
            S = S + DABS(B(I,L))
   20    CONTINUE
C
         IF (S .EQ. 0.0D0) GO TO 100
         S = S + DABS(B(L,L))
         R = 0.0D0
C
         DO 25 I = L, IGH
            B(I,L) = B(I,L) / S
            R = R + B(I,L)**2
   25    CONTINUE
C
         R = DSIGN(DSQRT(R),B(L,L))
         B(L,L) = B(L,L) + R
         RHO = R * B(L,L)
C
         DO 50 J = L1, N
            T = 0.0D0
C
            DO 30 I = L, IGH
               T = T + B(I,L) * B(I,J)
   30       CONTINUE
C
            T = -T / RHO
C
            DO 40 I = L, IGH
               B(I,J) = B(I,J) + T * B(I,L)
   40       CONTINUE
C
   50    CONTINUE
C
         DO 80 J = LOW, N
            T = 0.0D0
C
            DO 60 I = L, IGH
               T = T + B(I,L) * A(I,J)
   60       CONTINUE
C
            T = -T / RHO
C
            DO 70 I = L, IGH
               A(I,J) = A(I,J) + T * B(I,L)
   70       CONTINUE
C
   80    CONTINUE
C
         B(L,L) = -S * R
C
         DO 90 I = L1, IGH
            B(I,L) = 0.0D0
   90    CONTINUE
C
  100 CONTINUE
C     ********** REDUCE A TO UPPER HESSENBERG FORM, WHILE
C                KEEPING B TRIANGULAR **********
      IF (LOW .EQ. IGHM1) GO TO 170
      IGHM2 = IGH-2
C
      DO 160 K = LOW, IGHM2
         NK1 = IGHM1 - K
C     ********** FOR L=IGH-1 STEP -1 UNTIL K+1 DO -- **********
         DO 150 LB = 1, NK1
            L = IGH - LB
            L1 = L + 1
C     ********** ZERO A(L+1,K) **********
            S = DABS(A(L,K)) + DABS(A(L1,K))
            IF (S .EQ. 0.0D0) GO TO 150
            U1 = A(L,K) / S
            U2 = A(L1,K) / S
            R = DSIGN(DSQRT(U1*U1+U2*U2),U1)
            V1 =  -(U1 + R) / R
            V2 = -U2 / R
            U2 = V2 / V1
C
            DO 110 J = K, N
               T = A(L,J) + U2 * A(L1,J)
               A(L,J) = A(L,J) + T * V1
               A(L1,J) = A(L1,J) + T * V2
  110       CONTINUE
C
            A(L1,K) = 0.0D0
C
            DO 120 J = L, N
               T = B(L,J) + U2 * B(L1,J)
               B(L,J) = B(L,J) + T * V1
               B(L1,J) = B(L1,J) + T * V2
  120       CONTINUE
C     ********** ZERO B(L+1,L) **********
            S = DABS(B(L1,L1)) + DABS(B(L1,L))
            IF (S .EQ. 0.0D0) GO TO 150
            U1 = B(L1,L1) / S
            U2 = B(L1,L) / S
            R = DSIGN(DSQRT(U1*U1+U2*U2),U1)
            V1 =  -(U1 + R) / R
            V2 = -U2 / R
            U2 = V2 / V1
C
            DO 130 I = 1, L1
               T = B(I,L1) + U2 * B(I,L)
               B(I,L1) = B(I,L1) + T * V1
               B(I,L) = B(I,L) + T * V2
  130       CONTINUE
C
            B(L1,L) = 0.0D0
C
            DO 140 I = 1, IGH
               T = A(I,L1) + U2 * A(I,L)
               A(I,L1) = A(I,L1) + T * V1
               A(I,L) = A(I,L) + T * V2
  140       CONTINUE
C
            IF (.NOT. MATZ) GO TO 150
C
            DO 145 I = LOW, IGH
               T = Z(I,L1) + U2 * Z(I,L)
               Z(I,L1) = Z(I,L1) + T * V1
               Z(I,L) = Z(I,L) + T * V2
  145       CONTINUE
C
  150    CONTINUE
C
  160 CONTINUE
C
  170 RETURN
C     ********** LAST CARD OF QZHESW **********
      END
      SUBROUTINE QZITW(NM,N,A,B,LOW,IGH,EPS1,MATZ,Z,IERR)
C
      INTEGER I,J,K,L,N,EN,K1,K2,LD,LL,L1,NA,NM,ISH,ITS,KM1,LM1,
     X        ENM2,IERR,LOR1,ENORN,LOW,IGH,LOWP1
      DOUBLE PRECISION A(NM,N),B(NM,N),Z(NM,N)
      DOUBLE PRECISION R,S,T,A1,A2,A3,EP,SH,U1,U2,U3,V1,V2,V3,ANI,
     X       A11,A12,A21,A22,A33,A34,A43,A44,BNI,B11,B12,B22,B33,B34,
     X       B44,EPSA,EPSB,EPS1,ANORM,BNORM
      DOUBLE PRECISION DSQRT,DABS,DSIGN
      INTEGER MAX0,MIN0
      LOGICAL MATZ,NOTLAS
C
C     THIS SUBROUTINE IS THE SECOND STEP OF THE QZ ALGORITHM
C     FOR SOLVING GENERALIZED MATRIX EIGENVALUE PROBLEMS,
C     SIAM J. NUMER. ANAL. 10, 241-256(1973) BY MOLER AND STEWART,
C     AS MODIFIED IN TECHNICAL NOTE NASA TN E-7305(1973) BY WARD.
C     THE CODE IS A MODIFICATION OF SUBROUTINE QZIT FOUND IN EISPACK
C     SO AS TO ACCEPT PARTITIONED MATRICES AS PRODUCED BY THE
C     BALANCING ALGORITHM OF WARD IN SIAM J. SCIEN. STAT. COMPU. 2,
C     141-152 (1981)
C
C     THIS SUBROUTINE ACCEPTS A PAIR OF REAL MATRICES, ONE OF THEM
C     IN UPPER HESSENBERG FORM AND THE OTHER IN UPPER TRIANGULAR FORM.
C     IT REDUCES THE HESSENBERG MATRIX TO QUASI-TRIANGULAR FORM USING
C     ORTHOGONAL TRANSFORMATIONS WHILE MAINTAINING THE TRIANGULAR FORM
C     OF THE OTHER MATRIX.  IT IS USUALLY PRECEDED BY  QZHESW  AND
C     FOLLOWED BY  QZVAL  AND, POSSIBLY,  QZVEC.
C
C     ON INPUT-
C
C        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL
C          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
C          DIMENSION STATEMENT,
C
C        N IS THE ORDER OF THE MATRICES,
C
C        A CONTAINS A REAL UPPER HESSENBERG MATRIX,
C
C        B CONTAINS A REAL UPPER TRIANGULAR MATRIX,
C
C        LOW IS THE STARTING INDEX FOR THE SCALED SUBMATRICES OF
C          A AND B OBTAINED FROM THE BALANCING ALGORITHM.
C          IF THE MATRICES HAVE NOT BEEN BALANCED, SET LOW TO 1.
C
C        IGH IS THE ENDING INDEX FOR THE SCALED SUBMATRICES OF
C          A AND B OBTAINED FROM THE BALANCING ALGORITHM.
C          IF THE MATRICES HAVE NOT BEEN BALANCED, SET IGH TO N.
C
C        EPS1 IS A TOLERANCE USED TO DETERMINE NEGLIGIBLE ELEMENTS.
C          EPS1 = 0.0D0 (OR NEGATIVE) MAY BE INPUT, IN WHICH CASE AN
C          ELEMENT WILL BE NEGLECTED ONLY IF IT IS LESS THAN ROUNDOFF
C          ERROR TIMES THE NORM OF ITS MATRIX.  IF THE INPUT EPS1 IS
C          POSITIVE, THEN AN ELEMENT WILL BE CONSIDERED NEGLIGIBLE
C          IF IT IS LESS THAN EPS1 TIMES THE NORM OF ITS MATRIX.  A
C          POSITIVE VALUE OF EPS1 MAY RESULT IN FASTER EXECUTION,
C          BUT LESS ACCURATE RESULTS,
C
C        MATZ SHOULD BE SET TO .TRUE. IF THE RIGHT HAND TRANSFORMATIONS
C          ARE TO BE ACCUMULATED FOR LATER USE IN COMPUTING
C          EIGENVECTORS, AND TO .FALSE. OTHERWISE,
C
C        Z CONTAINS, IF MATZ HAS BEEN SET TO .TRUE., THE
C          TRANSFORMATION MATRIX PRODUCED IN THE REDUCTION
C          BY  QZHES, IF PERFORMED, OR ELSE THE IDENTITY MATRIX.
C          IF MATZ HAS BEEN SET TO .FALSE., Z IS NOT REFERENCED.
C
C     ON OUTPUT-
C
C        A HAS BEEN REDUCED TO QUASI-TRIANGULAR FORM.  THE ELEMENTS
C          BELOW THE FIRST SUBDIAGONAL ARE STILL ZERO AND NO TWO
C          CONSECUTIVE SUBDIAGONAL ELEMENTS ARE NONZERO,
C
C        B IS STILL IN UPPER TRIANGULAR FORM, ALTHOUGH ITS ELEMENTS
C          HAVE BEEN ALTERED.  THE LOCATION B(N,1) IS USED TO STORE
C          EPS1 TIMES THE NORM OF B FOR LATER USE BY  QZVAL  AND  QZVEC,
C
C        Z CONTAINS THE PRODUCT OF THE RIGHT HAND TRANSFORMATIONS
C          (FOR BOTH STEPS) IF MATZ HAS BEEN SET TO .TRUE.,
C
C        IERR IS SET TO
C          ZERO       FOR NORMAL RETURN,
C          J          IF NEITHER A(J,J-1) NOR A(J-1,J-2) HAS BECOME
C                     ZERO AFTER 50 ITERATIONS.
C
C     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO R. C. WARD,
C     UNION CARBIDE CORP.-NUCLEAR DIVISION, P.O. BOX Y, BLDG.
C     9704-1, OAK RIDGE, TENNESSEE 37830.
C
C     ------------------------------------------------------------------
C
      IERR = 0
C     ********** COMPUTE EPSA,EPSB **********
      ANORM = 0.0D0
      BNORM = 0.0D0
C
      DO 30 I = LOW, IGH
         ANI = 0.0D0
         IF (I .NE. LOW) ANI = DABS(A(I,I-1))
         BNI = 0.0D0
C
         DO 20 J = I, IGH
            ANI = ANI + DABS(A(I,J))
            BNI = BNI + DABS(B(I,J))
   20    CONTINUE
C
         IF (ANI .GT. ANORM) ANORM = ANI
         IF (BNI .GT. BNORM) BNORM = BNI
   30 CONTINUE
C
      IF (ANORM .EQ. 0.0D0) ANORM = 1.0D0
      IF (BNORM .EQ. 0.0D0) BNORM = 1.0D0
      EP = EPS1
      IF (EP .GT. 0.0D0) GO TO 50
C     ********** COMPUTE ROUNDOFF LEVEL IF EPS1 IS ZERO **********
      EP = 1.0D0
   40 EP = EP / 2.0
      IF (1.0D0 + EP .GT. 1.0D0) GO TO 40
   50 EPSA = EP * ANORM
      EPSB = EP * BNORM
C     ********** REDUCE A TO QUASI-TRIANGULAR FORM, WHILE
C                KEEPING B TRIANGULAR **********
      LOR1 = 1
      ENORN = N
      EN = IGH
      LOWP1 = LOW + 1
C     ********** BEGIN QZ STEP **********
   60 IF (EN .LE. LOWP1) GO TO 1001
      IF (.NOT. MATZ) ENORN = EN
      ITS = 0
      NA = EN - 1
      ENM2 = NA - 1
   70 ISH = 2
C     ********** CHECK FOR CONVERGENCE OR REDUCIBILITY.
C                FOR L=EN STEP -1 UNTIL 1 DO -- **********
      DO 80 LL = LOW, EN
         L = EN + LOW - LL
         IF (L .EQ. LOW) GO TO 95
         LM1 = L - 1
         IF (DABS(A(L,LM1)) .LE. EPSA) GO TO 90
   80 CONTINUE
C
   90 A(L,LM1) = 0.0D0
      IF (L .LT. NA) GO TO 95
C     ********** 1-BY-1 OR 2-BY-2 BLOCK ISOLATED **********
      EN = LM1
      GO TO 60
C     ********** CHECK FOR SMALL TOP OF B **********
   95 LD = L
  100 L1 = L + 1
      B11 = B(L,L)
      IF (DABS(B11) .GT. EPSB) GO TO 120
      B(L,L) = 0.0D0
      S = DABS(A(L,L)) + DABS(A(L1,L))
      U1 = A(L,L) / S
      U2 = A(L1,L) / S
      R = DSIGN(DSQRT(U1*U1+U2*U2),U1)
      V1 = -(U1 + R) / R
      V2 = -U2 / R
      U2 = V2 / V1
C
      DO 110 J = L, ENORN
         T = A(L,J) + U2 * A(L1,J)
         A(L,J) = A(L,J) + T * V1
         A(L1,J) = A(L1,J) + T * V2
         T = B(L,J) + U2 * B(L1,J)
         B(L,J) = B(L,J) + T * V1
         B(L1,J) = B(L1,J) + T * V2
  110 CONTINUE
C
      IF (L .NE. LOW) A(L,LM1) = -A(L,LM1)
      LM1 = L
      L = L1
      GO TO 90
  120 A11 = A(L,L) / B11
      A21 = A(L1,L) / B11
      IF (ISH .EQ. 1) GO TO 140
C     ********** ITERATION STRATEGY **********
      IF (ITS .EQ. 50) GO TO 1000
      IF (ITS .EQ. 10) GO TO 155
C     ********** DETERMINE TYPE OF SHIFT **********
      B22 = B(L1,L1)
      IF (DABS(B22) .LT. EPSB) B22 = EPSB
      B33 = B(NA,NA)
      IF (DABS(B33) .LT. EPSB) B33 = EPSB
      B44 = B(EN,EN)
      IF (DABS(B44) .LT. EPSB) B44 = EPSB
      A33 = A(NA,NA) / B33
      A34 = A(NA,EN) / B44
      A43 = A(EN,NA) / B33
      A44 = A(EN,EN) / B44
      B34 = B(NA,EN) / B44
      T = 0.5 * (A43 * B34 - A33 - A44)
      R = T * T + A34 * A43 - A33 * A44
      IF (R .LT. 0.0D0) GO TO 150
C     ********** DETERMINE SINGLE SHIFT ZEROTH COLUMN OF A **********
      ISH = 1
      R = DSQRT(R)
      SH = -T + R
      S = -T - R
      IF (DABS(S-A44) .LT. DABS(SH-A44)) SH = S
C     ********** LOOK FOR TWO CONSECUTIVE SMALL
C                SUB-DIAGONAL ELEMENTS OF A.
C                FOR L=EN-2 STEP -1 UNTIL LD DO -- **********
      DO 130 LL = LD, ENM2
         L = ENM2 + LD - LL
         IF (L .EQ. LD) GO TO 140
         LM1 = L - 1
         L1 = L + 1
         T = A(L,L)
         IF (DABS(B(L,L)) .GT. EPSB) T = T - SH * B(L,L)
         IF (DABS(A(L,LM1)) .LE. DABS(T/A(L1,L)) * EPSA) GO TO 100
  130 CONTINUE
C
  140 A1 = A11 - SH
      A2 = A21
      IF (L .NE. LD) A(L,LM1) = -A(L,LM1)
      GO TO 160
C     ********** DETERMINE DOUBLE SHIFT ZEROTH COLUMN OF A **********
  150 A12 = A(L,L1) / B22
      A22 = A(L1,L1) / B22
      B12 = B(L,L1) / B22
      A1 = ((A33 - A11) * (A44 - A11) - A34 * A43 + A43 * B34 * A11)
     X     / A21 + A12 - A11 * B12
      A2 = (A22 - A11) - A21 * B12 - (A33 - A11) - (A44 - A11)
     X     + A43 * B34
      A3 = A(L1+1,L1) / B22
      GO TO 160
C     ********** AD HOC SHIFT **********
  155 A1 = 0.0D0
      A2 = 1.0D0
      A3 = 1.1605D0
  160 ITS = ITS + 1
      IF (.NOT. MATZ) LOR1 = LD
C     ********** MAIN LOOP **********
      DO 260 K = L, NA
         NOTLAS = K .NE. NA .AND. ISH .EQ. 2
         K1 = K + 1
         K2 = K + 2
         KM1 = MAX0(K-1,L)
         LL = MIN0(EN,K1+ISH)
         IF (NOTLAS) GO TO 190
C     ********** ZERO A(K+1,K-1) **********
         IF (K .EQ. L) GO TO 170
         A1 = A(K,KM1)
         A2 = A(K1,KM1)
  170    S = DABS(A1) + DABS(A2)
         IF (S .EQ. 0.0D0) GO TO 70
         U1 = A1 / S
         U2 = A2 / S
         R = DSIGN(DSQRT(U1*U1+U2*U2),U1)
         V1 = -(U1 + R) / R
         V2 = -U2 / R
         U2 = V2 / V1
C
         DO 180 J = KM1, ENORN
            T = A(K,J) + U2 * A(K1,J)
            A(K,J) = A(K,J) + T * V1
            A(K1,J) = A(K1,J) + T * V2
            T = B(K,J) + U2 * B(K1,J)
            B(K,J) = B(K,J) + T * V1
            B(K1,J) = B(K1,J) + T * V2
  180    CONTINUE
C
         IF (K .NE. L) A(K1,KM1) = 0.0D0
         GO TO 240
C     ********** ZERO A(K+1,K-1) AND A(K+2,K-1) **********
  190    IF (K .EQ. L) GO TO 200
         A1 = A(K,KM1)
         A2 = A(K1,KM1)
         A3 = A(K2,KM1)
  200    S = DABS(A1) + DABS(A2) + DABS(A3)
         IF (S .EQ. 0.0D0) GO TO 260
         U1 = A1 / S
         U2 = A2 / S
         U3 = A3 / S
         R = DSIGN(DSQRT(U1*U1+U2*U2+U3*U3),U1)
         V1 = -(U1 + R) / R
         V2 = -U2 / R
         V3 = -U3 / R
         U2 = V2 / V1
         U3 = V3 / V1
C
         DO 210 J = KM1, ENORN
            T = A(K,J) + U2 * A(K1,J) + U3 * A(K2,J)
            A(K,J) = A(K,J) + T * V1
            A(K1,J) = A(K1,J) + T * V2
            A(K2,J) = A(K2,J) + T * V3
            T = B(K,J) + U2 * B(K1,J) + U3 * B(K2,J)
            B(K,J) = B(K,J) + T * V1
            B(K1,J) = B(K1,J) + T * V2
            B(K2,J) = B(K2,J) + T * V3
  210    CONTINUE
C
         IF (K .EQ. L) GO TO 220
         A(K1,KM1) = 0.0D0
         A(K2,KM1) = 0.0D0
C     ********** ZERO B(K+2,K+1) AND B(K+2,K) **********
  220    S = DABS(B(K2,K2)) + DABS(B(K2,K1)) + DABS(B(K2,K))
         IF (S .EQ. 0.0D0) GO TO 240
         U1 = B(K2,K2) / S
         U2 = B(K2,K1) / S
         U3 = B(K2,K) / S
         R = DSIGN(DSQRT(U1*U1+U2*U2+U3*U3),U1)
         V1 = -(U1 + R) / R
         V2 = -U2 / R
         V3 = -U3 / R
         U2 = V2 / V1
         U3 = V3 / V1
C
         DO 230 I = LOR1, LL
            T = A(I,K2) + U2 * A(I,K1) + U3 * A(I,K)
            A(I,K2) = A(I,K2) + T * V1
            A(I,K1) = A(I,K1) + T * V2
            A(I,K) = A(I,K) + T * V3
            T = B(I,K2) + U2 * B(I,K1) + U3 * B(I,K)
            B(I,K2) = B(I,K2) + T * V1
            B(I,K1) = B(I,K1) + T * V2
            B(I,K) = B(I,K) + T * V3
  230    CONTINUE
C
         B(K2,K) = 0.0D0
         B(K2,K1) = 0.0D0
         IF (.NOT. MATZ) GO TO 240
C
         DO 235 I = LOW, IGH
            T = Z(I,K2) + U2 * Z(I,K1) + U3 * Z(I,K)
            Z(I,K2) = Z(I,K2) + T * V1
            Z(I,K1) = Z(I,K1) + T * V2
            Z(I,K) = Z(I,K) + T * V3
  235    CONTINUE
C     ********** ZERO B(K+1,K) **********
  240    S = DABS(B(K1,K1)) + DABS(B(K1,K))
         IF (S .EQ. 0.0D0) GO TO 260
         U1 = B(K1,K1) / S
         U2 = B(K1,K) / S
         R = DSIGN(DSQRT(U1*U1+U2*U2),U1)
         V1 = -(U1 + R) / R
         V2 = -U2 / R
         U2 = V2 / V1
C
         DO 250 I = LOR1, LL
            T = A(I,K1) + U2 * A(I,K)
            A(I,K1) = A(I,K1) + T * V1
            A(I,K) = A(I,K) + T * V2
            T = B(I,K1) + U2 * B(I,K)
            B(I,K1) = B(I,K1) + T * V1
            B(I,K) = B(I,K) + T * V2
  250    CONTINUE
C
         B(K1,K) = 0.0D0
         IF (.NOT. MATZ) GO TO 260
C
         DO 255 I = LOW,IGH
            T = Z(I,K1) + U2 * Z(I,K)
            Z(I,K1) = Z(I,K1) + T * V1
            Z(I,K) = Z(I,K) + T * V2
  255    CONTINUE
C
  260 CONTINUE
C     ********** END QZ STEP **********
      GO TO 70
C     ********** SET ERROR -- NEITHER BOTTOM SUBDIAGONAL ELEMENT
C                HAS BECOME NEGLIGIBLE AFTER 50 ITERATIONS **********
 1000 IERR = EN
C     ********** SAVE EPSB FOR USE BY QZVAL AND QZVEC **********
 1001 IF (N .GT. 1) B(N,1) = EPSB
      RETURN
C     ********** LAST CARD OF QZITW **********
      END
      subroutine qzval(nm,n,a,b,alfr,alfi,beta,matz,z)
c
      integer i,j,n,en,na,nm,nn,isw
      double precision a(nm,n),b(nm,n),alfr(n),alfi(n),beta(n),z(nm,n)
      double precision c,d,e,r,s,t,an,a1,a2,bn,cq,cz,di,dr,ei,ti,tr,u1,
     x       u2,v1,v2,a1i,a11,a12,a2i,a21,a22,b11,b12,b22,sqi,sqr,
     x       ssi,ssr,szi,szr,a11i,a11r,a12i,a12r,a22i,a22r,epsb
      logical matz
c
c     this subroutine is the third step of the qz algorithm
c     for solving generalized matrix eigenvalue problems,
c     siam j. numer. anal. 10, 241-256(1973) by moler and stewart.
c
c     this subroutine accepts a pair of real matrices, one of them
c     in quasi-triangular form and the other in upper triangular form.
c     it reduces the quasi-triangular matrix further, so that any
c     remaining 2-by-2 blocks correspond to pairs of complex
c     eigenvalues, and returns quantities whose ratios give the
c     generalized eigenvalues.  it is usually preceded by  qzhes
c     and  qzit  and may be followed by  qzvec.
c
c     on input
c
c        nm must be set to the row dimension of two-dimensional
c          array parameters as declared in the calling program
c          dimension statement.
c
c        n is the order of the matrices.
c
c        a contains a real upper quasi-triangular matrix.
c
c        b contains a real upper triangular matrix.  in addition,
c          location b(n,1) contains the tolerance quantity (epsb)
c          computed and saved in  qzit.
c
c        matz should be set to .true. if the right hand transformations
c          are to be accumulated for later use in computing
c          eigenvectors, and to .false. otherwise.
c
c        z contains, if matz has been set to .true., the
c          transformation matrix produced in the reductions by qzhes
c          and qzit, if performed, or else the identity matrix.
c          if matz has been set to .false., z is not referenced.
c
c     on output
c
c        a has been reduced further to a quasi-triangular matrix
c          in which all nonzero subdiagonal elements correspond to
c          pairs of complex eigenvalues.
c
c        b is still in upper triangular form, although its elements
c          have been altered.  b(n,1) is unaltered.
c
c        alfr and alfi contain the real and imaginary parts of the
c          diagonal elements of the triangular matrix that would be
c          obtained if a were reduced completely to triangular form
c          by unitary transformations.  non-zero values of alfi occur
c          in pairs, the first member positive and the second negative.
c
c        beta contains the diagonal elements of the corresponding b,
c          normalized to be real and non-negative.  the generalized
c          eigenvalues are then the ratios ((alfr+i*alfi)/beta).
c
c        z contains the product of the right hand transformations
c          (for all three steps) if matz has been set to .true.
c
c     questions and comments should be directed to burton s. garbow,
c     mathematics and computer science div, argonne national laboratory
c
c     this version dated august 1983.
c
c     ------------------------------------------------------------------
c
      epsb = b(n,1)
      isw = 1
c     .......... find eigenvalues of quasi-triangular matrices.
c                for en=n step -1 until 1 do -- ..........
      do 510 nn = 1, n
         en = n + 1 - nn
         na = en - 1
         if (isw .eq. 2) go to 505
         if (en .eq. 1) go to 410
         if (a(en,na) .ne. 0.0d0) go to 420
c     .......... 1-by-1 block, one real root ..........
  410    alfr(en) = a(en,en)
         if (b(en,en) .lt. 0.0d0) alfr(en) = -alfr(en)
         beta(en) = dabs(b(en,en))
         alfi(en) = 0.0d0
         go to 510
c     .......... 2-by-2 block ..........
  420    if (dabs(b(na,na)) .le. epsb) go to 455
         if (dabs(b(en,en)) .gt. epsb) go to 430
         a1 = a(en,en)
         a2 = a(en,na)
         bn = 0.0d0
         go to 435
  430    an = dabs(a(na,na)) + dabs(a(na,en)) + dabs(a(en,na))
     x      + dabs(a(en,en))
         bn = dabs(b(na,na)) + dabs(b(na,en)) + dabs(b(en,en))
         a11 = a(na,na) / an
         a12 = a(na,en) / an
         a21 = a(en,na) / an
         a22 = a(en,en) / an
         b11 = b(na,na) / bn
         b12 = b(na,en) / bn
         b22 = b(en,en) / bn
         e = a11 / b11
         ei = a22 / b22
         s = a21 / (b11 * b22)
         t = (a22 - e * b22) / b22
         if (dabs(e) .le. dabs(ei)) go to 431
         e = ei
         t = (a11 - e * b11) / b11
  431    c = 0.5d0 * (t - s * b12)
         d = c * c + s * (a12 - e * b12)
         if (d .lt. 0.0d0) go to 480
c     .......... two real roots.
c                zero both a(en,na) and b(en,na) ..........
         e = e + (c + dsign(dsqrt(d),c))
         a11 = a11 - e * b11
         a12 = a12 - e * b12
         a22 = a22 - e * b22
         if (dabs(a11) + dabs(a12) .lt.
     x       dabs(a21) + dabs(a22)) go to 432
         a1 = a12
         a2 = a11
         go to 435
  432    a1 = a22
         a2 = a21
c     .......... choose and apply real z ..........
  435    s = dabs(a1) + dabs(a2)
         u1 = a1 / s
         u2 = a2 / s
         r = dsign(dsqrt(u1*u1+u2*u2),u1)
         v1 = -(u1 + r) / r
         v2 = -u2 / r
         u2 = v2 / v1
c
         do 440 i = 1, en
            t = a(i,en) + u2 * a(i,na)
            a(i,en) = a(i,en) + t * v1
            a(i,na) = a(i,na) + t * v2
            t = b(i,en) + u2 * b(i,na)
            b(i,en) = b(i,en) + t * v1
            b(i,na) = b(i,na) + t * v2
  440    continue
c
         if (.not. matz) go to 450
c
         do 445 i = 1, n
            t = z(i,en) + u2 * z(i,na)
            z(i,en) = z(i,en) + t * v1
            z(i,na) = z(i,na) + t * v2
  445    continue
c
  450    if (bn .eq. 0.0d0) go to 475
         if (an .lt. dabs(e) * bn) go to 455
         a1 = b(na,na)
         a2 = b(en,na)
         go to 460
  455    a1 = a(na,na)
         a2 = a(en,na)
c     .......... choose and apply real q ..........
  460    s = dabs(a1) + dabs(a2)
         if (s .eq. 0.0d0) go to 475
         u1 = a1 / s
         u2 = a2 / s
         r = dsign(dsqrt(u1*u1+u2*u2),u1)
         v1 = -(u1 + r) / r
         v2 = -u2 / r
         u2 = v2 / v1
c
         do 470 j = na, n
            t = a(na,j) + u2 * a(en,j)
            a(na,j) = a(na,j) + t * v1
            a(en,j) = a(en,j) + t * v2
            t = b(na,j) + u2 * b(en,j)
            b(na,j) = b(na,j) + t * v1
            b(en,j) = b(en,j) + t * v2
  470    continue
c
  475    a(en,na) = 0.0d0
         b(en,na) = 0.0d0
         alfr(na) = a(na,na)
         alfr(en) = a(en,en)
         if (b(na,na) .lt. 0.0d0) alfr(na) = -alfr(na)
         if (b(en,en) .lt. 0.0d0) alfr(en) = -alfr(en)
         beta(na) = dabs(b(na,na))
         beta(en) = dabs(b(en,en))
         alfi(en) = 0.0d0
         alfi(na) = 0.0d0
         go to 505
c     .......... two complex roots ..........
  480    e = e + c
         ei = dsqrt(-d)
         a11r = a11 - e * b11
         a11i = ei * b11
         a12r = a12 - e * b12
         a12i = ei * b12
         a22r = a22 - e * b22
         a22i = ei * b22
         if (dabs(a11r) + dabs(a11i) + dabs(a12r) + dabs(a12i) .lt.
     x       dabs(a21) + dabs(a22r) + dabs(a22i)) go to 482
         a1 = a12r
         a1i = a12i
         a2 = -a11r
         a2i = -a11i
         go to 485
  482    a1 = a22r
         a1i = a22i
         a2 = -a21
         a2i = 0.0d0
c     .......... choose complex z ..........
  485    cz = dsqrt(a1*a1+a1i*a1i)
         if (cz .eq. 0.0d0) go to 487
         szr = (a1 * a2 + a1i * a2i) / cz
         szi = (a1 * a2i - a1i * a2) / cz
         r = dsqrt(cz*cz+szr*szr+szi*szi)
         cz = cz / r
         szr = szr / r
         szi = szi / r
         go to 490
  487    szr = 1.0d0
         szi = 0.0d0
  490    if (an .lt. (dabs(e) + ei) * bn) go to 492
         a1 = cz * b11 + szr * b12
         a1i = szi * b12
         a2 = szr * b22
         a2i = szi * b22
         go to 495
  492    a1 = cz * a11 + szr * a12
         a1i = szi * a12
         a2 = cz * a21 + szr * a22
         a2i = szi * a22
c     .......... choose complex q ..........
  495    cq = dsqrt(a1*a1+a1i*a1i)
         if (cq .eq. 0.0d0) go to 497
         sqr = (a1 * a2 + a1i * a2i) / cq
         sqi = (a1 * a2i - a1i * a2) / cq
         r = dsqrt(cq*cq+sqr*sqr+sqi*sqi)
         cq = cq / r
         sqr = sqr / r
         sqi = sqi / r
         go to 500
  497    sqr = 1.0d0
         sqi = 0.0d0
c     .......... compute diagonal elements that would result
c                if transformations were applied ..........
  500    ssr = sqr * szr + sqi * szi
         ssi = sqr * szi - sqi * szr
         i = 1
         tr = cq * cz * a11 + cq * szr * a12 + sqr * cz * a21
     x      + ssr * a22
         ti = cq * szi * a12 - sqi * cz * a21 + ssi * a22
         dr = cq * cz * b11 + cq * szr * b12 + ssr * b22
         di = cq * szi * b12 + ssi * b22
         go to 503
  502    i = 2
         tr = ssr * a11 - sqr * cz * a12 - cq * szr * a21
     x      + cq * cz * a22
         ti = -ssi * a11 - sqi * cz * a12 + cq * szi * a21
         dr = ssr * b11 - sqr * cz * b12 + cq * cz * b22
         di = -ssi * b11 - sqi * cz * b12
  503    t = ti * dr - tr * di
         j = na
         if (t .lt. 0.0d0) j = en
         r = dsqrt(dr*dr+di*di)
         beta(j) = bn * r
         alfr(j) = an * (tr * dr + ti * di) / r
         alfi(j) = an * t / r
         if (i .eq. 1) go to 502
  505    isw = 3 - isw
  510 continue
      b(n,1) = epsb
c
      return
      end
      SUBROUTINE REDUCE (N,MA,A,MB,B,LOW,IGH,CSCALE,WK)
C
C     *****PARAMETERS:
      INTEGER IGH,LOW,MA,MB,N
      DOUBLE PRECISION A(MA,N),B(MB,N),CSCALE(N),WK(N)
C
C     *****LOCAL VARIABLES:
      INTEGER I,IFLOW,II,IP1,IS,J,JP1,K,L,LM1,M
      DOUBLE PRECISION F
C
C     *****FUNCTIONS:
C     NONE
C
C     *****SUBROUTINES CALLED:
C     NONE
C
C     ---------------------------------------------------------------
C
C     *****PURPOSE:
C     THIS SUBROUTINE REDUCES, IF POSSIBLE, THE ORDER OF THE
C     GENERALIZED EIGENVALUE PROBLEM A*X = (LAMBDA)*B*X BY PERMUTING
C     THE ROWS AND COLUMNS OF A AND B SO THAT THEY EACH HAVE THE
C     FORM
C                       U  X  Y
C                       0  C  Z
C                       0  0  R
C
C     WHERE U AND R ARE UPPER TRIANGULAR AND C, X, Y, AND Z ARE
C     ARBITRARY.  THUS, THE ISOLATED EIGENVALUES CORRESPONDING TO
C     THE TRIANGULAR MATRICES ARE OBTAINED BY A DIVISION, LEAVING
C     ONLY EIGENVALUES CORRESPONDING TO THE CENTER MATRICES TO BE
C     COMPUTED.
C     REF.:  WARD, R. C., BALANCING THE GENERALIZED EIGENVALUE
C     PROBLEM, SIAM J. SCI. STAT. COMPUT., VOL. 2, NO. 2, JUNE 1981,
C     141-152.
C
C     *****PARAMETER DESCRIPTION:
C
C     ON INPUT:
C
C       MA,MB   INTEGER
C               ROW DIMENSIONS OF THE ARRAYS CONTAINING MATRICES
C               A AND B RESPECTIVELY, AS DECLARED IN THE MAIN CALLING
C               PROGRAM DIMENSION STATEMENT;
C
C       N       INTEGER
C               ORDER OF THE MATRICES A AND B;
C
C       A       REAL(MA,N)
C               CONTAINS THE A MATRIX OF THE GENERALIZED EIGENPROBLEM
C               DEFINED ABOVE;
C
C       B       REAL(MB,N)
C               CONTAINS THE B MATRIX OF THE GENERALIZED EIGENPROBLEM
C               DEFINED ABOVE.
C
C     ON OUTPUT:
C
C       A,B     CONTAIN THE PERMUTED A AND B MATRICES;
C
C       LOW     INTEGER
C               BEGINNING INDEX OF THE SUBMATRICES OF A AND B
C               CONTAINING THE NON-ISOLATED EIGENVALUES;
C
C       IGH     INTEGER
C               ENDING INDEX OF THE SUBMATRICES OF A AND B
C               CONTAINING THE NON-ISOLATED EIGENVALUES.  IF
C               IGH = 1 (LOW = 1 ALSO), THE PERMUTED A AND B
C               MATRICES ARE UPPER TRIANGULAR;
C
C       CSCALE  REAL(N)
C               CONTAINS THE REQUIRED COLUMN PERMUTATIONS IN ITS
C               FIRST LOW-1 AND ITS IGH+1 THROUGH N LOCATIONS;
C
C       WK      REAL(N)
C               CONTAINS THE REQUIRED ROW PERMUTATIONS IN ITS FIRST
C               LOW-1 AND ITS IGH+1 THROUGH N LOCATIONS.
C
C     *****ALGORITHM NOTES:
C     NONE
C
C     *****HISTORY:
C     WRITTEN BY R. C. WARD.......
C
C     ---------------------------------------------------------------
C
      K = 1
      L = N
      GO TO 20
C
C     FIND ROW WITH ONE NONZERO IN COLUMNS 1 THROUGH L
C
   10 CONTINUE
      L = LM1
      IF (L .NE. 1) GO TO 20
      WK(1) = 1
      CSCALE(1) = 1
      GO TO 200
   20 CONTINUE
      LM1 = L-1
      DO 70 II = 1,L
         I = L+1-II
         DO 30 J = 1,LM1
            JP1 = J+1
            IF (A(I,J) .NE. 0.0D0 .OR. B(I,J) .NE. 0.0D0) GO TO 40
   30    CONTINUE
         J = L
         GO TO 60
   40    CONTINUE
         DO 50 J = JP1,L
            IF (A(I,J) .NE. 0.0D0 .OR. B(I,J) .NE. 0.0D0) GO TO 70
   50    CONTINUE
         J = JP1-1
   60    CONTINUE
         M = L
         IFLOW = 1
         GO TO 150
   70 CONTINUE
      GO TO 90
C
C     FIND COLUMN WITH ONE NONZERO IN ROWS K THROUGH N
C
   80 CONTINUE
      K = K+1
   90 CONTINUE
      DO 140 J = K,L
         DO 100 I = K,LM1
            IP1 = I+1
            IF (A(I,J) .NE. 0.0D0 .OR. B(I,J) .NE. 0.0D0) GO TO 110
  100    CONTINUE
         I = L
         GO TO 130
  110    CONTINUE
         DO 120 I = IP1,L
            IF (A(I,J) .NE. 0.0D0 .OR. B(I,J) .NE. 0.0D0) GO TO 140
  120    CONTINUE
         I = IP1-1
  130    CONTINUE
         M = K
         IFLOW = 2
         GO TO 150
  140 CONTINUE
      GO TO 200
C
C     PERMUTE ROWS M AND I
C
  150 CONTINUE
      WK(M) = I
      IF (I .EQ. M) GO TO 170
      DO 160 IS = K,N
         F = A(I,IS)
         A(I,IS) = A(M,IS)
         A(M,IS) = F
         F = B(I,IS)
         B(I,IS) = B(M,IS)
         B(M,IS) = F
  160 CONTINUE
C
C     PERMUTE COLUMNS M AND J
C
  170 CONTINUE
      CSCALE(M) = J
      IF (J .EQ. M) GO TO 190
      DO 180 IS = 1,L
         F = A(IS,J)
         A(IS,J) = A(IS,M)
         A(IS,M) = F
         F = B(IS,J)
         B(IS,J) = B(IS,M)
         B(IS,M) = F
  180 CONTINUE
  190 CONTINUE
      GO TO (10,80), IFLOW
  200 CONTINUE
      LOW = K
      IGH = L
      RETURN
C
C     LAST LINE OF REDUCE
C
      END
      SUBROUTINE RICSOL(NR,NRD,NN,N,G,F,E,Z,ALFR,ALFI,BETA,CPERM,
     X                  CSCALE,IND,IORD,IBAL,TYPE,EFLAG)
C
C     *****PARAMETERS:
      INTEGER NR,NRD,NN,N,IND(NN),IORD,IBAL
      CHARACTER EFLAG
      DOUBLE PRECISION G(NRD,NN),F(NRD,NN),E(NR,N),Z(NRD,NN),
     X          ALFR(NN),ALFI(NN),BETA(NN),CPERM(NN),CSCALE(NN)
      LOGICAL TYPE
C
C     *****LOCAL VARIABLES:
      INTEGER I,IERR,IFAIL,IGH,J,LOW,NPJ
      DOUBLE PRECISION COND,EPS,EPS1
      LOGICAL MATZ
C
C     *****FORTRAN FUNCTIONS:
C     NONE
C
C     *****SUBROUTINES CALLED:
C     BALGBK, BALGEN, MLINEQ, MULB, ORDER, QZHESW, QZITW, QZVAL
C
C     --------------------------------------------------------------
C
C     *****PURPOSE:
C     GIVEN THE 2N BY 2N MATRIX PENCIL
C
C              LAMBDA * F  -  G
C
C     THIS SUBROUTINE FINDS THE ORTHOGONAL MATRIX Z SUCH THAT
C
C              Q * (LAMBDA * F  -  G) * Z
C
C     IS IN GENERALIZED ORDERED REAL SCHUR FORM.  FURTHERMORE, THE
C     UPPER LEFT N BY N BLOCK OF THE TRANSFORMED PENCIL CONTAINS
C     THE EIGENVALUES SPECIFIED BY THE PARAMETER IORD.  THE
C     SUBROUTINE THEN SOLVES THE LINEAR SYSTEM
C
C              X * E * Z11  =  Z21
C
C     FOR X, WHERE Z11 AND Z21 ARE THE UPPER AND LOWER LEFT N BY N
C     BLOCKS OF Z.
C
C     REF.:  ARNOLD, W.F., "ON THE NUMERICAL SOLUTION OF
C     ALGEBRAIC MATRIX RICCATI EQUATIONS," PHD THESIS, USC,
C     DECEMBER 1983.
C
C     *****PARAMETER DESCRIPTION:
C
C     ON INPUT:
C
C       NR      INTEGER
C               ROW DIMENSION OF THE ARRAY CONTAINING THE MATRIX E
C               AS DECLARED IN THE MAIN CALLING PROGRAM DIMENSION
C               STATEMENT;
C
C       NRD     INTEGER
C               ROW DIMENSION OF THE ARRAYS CONTAINING THE MATRICES
C               G, F AND Z AS DECLARED IN THE MAIN CALLING PROGRAM
C               DIMENSION STATEMENT;
C
C       NN      INTEGER
C               ORDER OF THE SQUARE MATRICES G AND F;
C
C       N       INTEGER
C               ORDER OF THE SQUARE MATRIX E;
C
C       G       REAL(NRD,NN)
C               PENCIL MATRIX CORRESPONDING TO THE GENERALIZED RICCATI
C               PROBLEM, WHOSE CONTENTS ARE ALTERED BY THIS ROUTINE;
C
C       F       REAL(NRD,NN)
C               PENCIL MATRIX CORRESPONDING TO THE GENERALIZED RICCATI
C               PROBLEM, WHOSE CONTENTS ARE ALTERED BY THIS ROUTINE;
C
C       E       REAL(NR,N)
C               DESCRIPTOR MATRIX
C
C       CPERM   REAL(NN)
C               WORKING VECTOR OF SIZE AT LEAST NN;
C
C       CSCALE  REAL(NN)
C               WORKING VECTOR OF SIZE AT LEAST NN;
C
C       IND     INTEGER(NN)
C               WORKING VECTOR OF SIZE AT LEAST NN;
C
C       IORD    INTEGER
C               PARAMETER SPECIFYING THE SPECTRUM OF THE UPPER LEFT N
C               BY N BLOCK OF THE ORDERED REAL SCHUR FORM AS FOLLOWS:
C               =  1  GENERALIZED EIGENVALUES WHOSE MAGNITUDE IS LESS
C                     THAN UNITY
C               =  0  ANY ORDER
C               = -1  GENERALIZED EIGENVALUES WHOSE REAL PARTS ARE
C                     LESS THAN ZERO;
C
C       IBAL    INTEGER
C               PARAMETER SPECIFYING THE BALANCING BEING EMPLOYED AS
C               FOLLOWS:
C               = 1  WARD BALANCING
C               = 0  NO BALANCING
C
C       TYPE    LOGICAL
C               = .TRUE.  FOR CONTINUOUS-TIME SYSTEM
C               = .FALSE. FOR DISCRETE-TIME SYSTEM;
C
C       EFLAG   CHARACTER
C               FLAG SET TO 'Y' IF E IS A DESCRIPTOR MATRIX THAT IS
C               OTHER THAN THE IDENTITY MATRIX.
C
C     ON OUTPUT:
C
C       F       CONTAINS THE SOLUTION MATRIX X COMPUTED AS SHOWN
C               ABOVE;
C
C       Z       REAL(NRD,NN)
C               CONTAINS THE MATRIX PRODUCT
C                    ( E  0 )     ( Z11  Z12)
C                    (      )  *  (         )
C                    ( 0  I )     ( Z21  Z22)
C               WHERE Z IS THE ORTHOGONAL TRANSFORMATION MATRIX
C               DESCRIBED ABOVE;
C
C       ALFR    REAL(NN)
C               REAL PARTS OF THE DIAGONAL ELEMENTS THAT WOULD RESULT
C               IF THE Q AND Z TRANSFORMATIONS WERE APPLIED TO THE
C               G MATRIX SUCH THAT IT WOULD BE REDUCED COMPLETELY TO
C               TRIANGULAR FORM AND THE DIAGONAL ELEMENTS OF THE
C               TRANSFORMED F MATRIX (ALSO TRIANGULAR) WOULD BE REAL
C               AND POSITIVE;
C
C       ALFI    REAL(NN)
C               IMAGINARY PARTS OF THE DIAGONAL ELEMENTS THAT WOULD
C               RESULT IF THE Q AND THE Z TRANSFORMATIONS WERE
C               APPLIED TO THE G MATRIX SUCH THAT IT WOULD BE REDUCED
C               COMPLETELY TO TRIANGULAR FORM AND THE DIAGONAL
C               ELEMENTS OF THE TRANSFORMED F MATRIX (ALSO TRIANGULAR)
C               WOULD BE REAL AND POSITIVE.  NONZERO VALUES OCCUR IN
C               PAIRS; THE FIRST MEMBER IS POSITIVE AND THE SECOND
C               MEMBER IS NEGATIVE;
C
C       BETA    REAL(NN)
C               REAL NONNEGATIVE DIAGONAL ELEMENTS OF F THAT WOULD
C               RESULT IF G WERE REDUCED COMPLETELY TO TRIANGULAR
C               FORM; THE GENERALIZED EIGENVALUES ARE THEN GIVEN BY
C               THE RATIOS ((ALFR + I*ALFI)/BETA);
C
C       CPERM(1)
C               CONDITION ESTIMATE OF E*Z11 WITH RESPECT TO INVERSION;
C
C       IND(1)  ERROR FLAG AS FOLLOWS
C               = 0  INDICATES NORMAL RETURN
C               = NONZERO IF MORE THAT 50 ITERATIONS WERE REQUIRED TO
C               DETERMINE THE DIAGONAL BLOCKS FOR THE QUASITRIANGULAR
C               FORM;
C
C       IND(2)  ERROR FLAG AS FOLLOWS
C               = 0  INDICATES NORMAL RETURN
C               = 1  INDICATES ATTEMPTED REORDERING FAILED.
C
C     *****ALGORITHM NOTES:
C     NONE
C
C     *****HISTORY:
C     THIS SUBROUTINE WAS WRITTEN BY W.F. ARNOLD, NAVAL WEAPONS
C     CENTER, CODE 35104, CHINA LAKE, CA  93555, AS PART OF THE
C     SOFTWARE PACKAGE RICPACK, SEPTEMBER 1983.
C     MODIFIED BY ALAN J. LAUB (UCSB): 01/06/85
C
C     --------------------------------------------------------------
C
      MATZ = .TRUE.
      LOW = 1
      IGH = NN
C
C     CALCULATE MACHINE PRECISION (EPS)
C
      EPS = 1.0D0
   10 CONTINUE
      EPS = EPS/2.0D0
      EPS1 = EPS + 1.0D0
      IF (EPS1 .GT. 1.0D0) GO TO 10
      EPS = EPS*2.0D0
C
C     WARD BALANCING IF REQUESTED
C
      IF (IBAL .EQ. 0) GO TO 20
      CALL BALGEN(NN,NRD,G,NRD,F,LOW,IGH,CSCALE,CPERM,Z)
   20 CONTINUE
C
C     CALCULATE GENERALIZED EIGENVALUES
C
      CALL QZHESW(NRD,NN,G,F,LOW,IGH,MATZ,Z)
      CALL QZITW(NRD,NN,G,F,LOW,IGH,EPS,MATZ,Z,IERR)
      CALL QZVAL(NRD,NN,G,F,ALFR,ALFI,BETA,MATZ,Z)
      EPS1 = F(NN,1)
C
C     ORDER EIGENVALUES
C
      IF(IORD .EQ. 0) GO TO 25
      CALL ORDER(G,F,Z,NRD,NN,EPS1,IFAIL,TYPE,IORD,IND)
   25 CONTINUE
      IF (IBAL .EQ. 0) GO TO 30
      CALL BALGBK(NN,NRD,Z,NN,LOW,IGH,CSCALE,CPERM)
   30 CONTINUE
C
C     CALCULATE RICCATI SOLUTION
C
      IF(EFLAG .NE. 'Y' .AND. EFLAG .NE. 'y') GO TO 35
      CALL MULB(NR,NRD,N,N,N,E,Z,CPERM)
   35 CONTINUE
      DO 50 J=1,N
         NPJ = N + J
         DO 40 I=1,N
            G(I,J) = Z(J,I)
            F(I,J) = Z(NPJ,I)
   40    CONTINUE
   50 CONTINUE
      CALL MLINEQ(NRD,NRD,N,N,G,F,COND,IND,CPERM)
      CPERM(1) = COND
      IND(1) = IERR
      IND(2) = IFAIL
      RETURN
C
C     LAST LINE OF RICSOL
C
      END
      SUBROUTINE ROTC (H,NMAX,N,L1,L2,M1,M2,S,C)
C
C     *****PARAMETERS:
      INTEGER L1,L2,M1,M2,N,NMAX
      DOUBLE PRECISION C,S,H(NMAX,N)
C
C     *****LOCAL VARIABLES:
      INTEGER I
      DOUBLE PRECISION T
C
C     *****FORTRAN FUNCTIONS:
C     NONE
C
C     *****SUBROUTINES CALLED:
C     NONE
C
C     ________________________________________________________________
C
C     *****PURPOSE:
C     THIS ROUTINE PERFORMS THE GIVENS ROTATION:
C
C                       \ C  S \
C                       \-S  C \
C
C     ON COLUMNS L1 AND L2 OF H, THIS FROM ROWS M1 TO M2.
C
C     *****PARAMETER DESCRIPTION:
C
C     ON INPUT:
C
C       NMAX    INTEGER
C               ROW DIMENSION OF THE ARRAYS CONTAINING A,B,Z AS
C               DECLARED IN THE MAIN CALLING PROGRAM DIMENSION STATEMENT;
C
C       N       INTEGER
C               ORDER OF THE MATRICES A,B,Z;
C
C       H       REAL(NMAX,N)
C               THE ARRAY UPON WHICH THE GIVENS ROTATION IS TO BE
C               PERFORMED;
C
C       L1,L2   INTEGER
C               COLUMNS INVOLVED IN THE ROTATION;
C
C       M1,M2   INTEGER
C               ROWS INVOLVED IN THE ROTATION;
C
C       C,S     REAL
C               ROTATION PARAMETERS.
C
C     ON OUTPUT:
C
C       H       THE ARRAY WHOSE COLUMNS HAVE BEEN MODIFIED AS SPECIFIED
C               ABOVE.
C
C     *****HISTORY:
C     WRITTEN BY P. VAN DOOREN("A GENERALIZED EIGENVALUE APPROACH
C     FOR SOLVING RICCATI EQUATIONS", INTERNAL REPORT NA-80-02,
C     DEPT. OF COMPUTER SCIENCE, STANFORD UNIVERSITY, 1980).
C
C     ----------------------------------------------------------------
C
      DO 10 I = M1,M2
         T = S*H(I,L1) + C*H(I,L2)
         H(I,L1) = C*H(I,L1) - S*H(I,L2)
         H(I,L2) = T
   10 CONTINUE
      RETURN
C
C     LAST LINE OF ROTC
C
      END
      SUBROUTINE ROTR (H,NMAX,N,L1,L2,M1,M2,S,C)
C
C     *****PARAMETERS:
      INTEGER L1,L2,M1,M2,N,NMAX
      DOUBLE PRECISION C,S,H(NMAX,N)
C
C     *****LOCAL VARIABLES:
      INTEGER J
      DOUBLE PRECISION T
C
C     *****FORTRAN FUNCTIONS:
C     NONE
C
C     *****SUBROUTINES CALLED:
C     NONE
C
C     ________________________________________________________________
C
C     *****PURPOSE:
C     THIS ROUTINE PERFORMS THE GIVENS ROTATION:
C
C                       \ S  C \
C                       \-C  S \
C
C     ON ROWS L1 AND L2 OF H, THIS FROM COLUMNS M1 TO M2.
C
C     *****PARAMETER DESCRIPTION:
C     ON INPUT:
C       NMAX    INTEGER
C               ROW DIMENSION OF THE ARRAYS CONTAINING A,B,Z AS
C               DECLARED IN THE CALLING PROGRAM DIMENSION STATEMENT;
C
C       N       INTEGER
C               ORDER OF THE MATRICES A,B,Z;
C
C       H       REAL(NMAX,N)
C               THE ARRAY UPON WHICH THE GIVENS ROTATION IS TO BE
C               PERFORMED;
C
C       L1,L2   INTEGER
C               ROWS INVOLVED IN THE ROTATION;
C
C       M1,M2   INTEGER
C               COLUMNS INVOLVED IN THE ROTATION;
C
C       C,S     REAL
C               ROTATION PARAMETERS.
C
C     ON OUTPUT:
C
C       H       THE ARRAY WHOSE ROWS HAVE BEEN MODIFIED AS SPECIFIED
C               ABOVE.
C
C     *****HISTORY:
C     WRITTEN BY P. VAN DOOREN("A GENERALIZED EIGENVALUE APPROACH
C     FOR SOLVING RICCATI EQUATIONS", INTERNAL REPORT NA-80-02,
C     DEPT. OF COMPUTER SCIENCE, STANFORD UNIVERSITY, 1980).
C
C     ----------------------------------------------------------------
C
      DO 10 J = M1,M2
         T = S*H(L1,J) + C*H(L2,J)
         H(L2,J) = -C*H(L1,J) + S*H(L2,J)
         H(L1,J) = T
   10 CONTINUE
      RETURN
C
C     LAST LINE OF ROTR
C
      END
      SUBROUTINE SCALBK (N,MZ,Z,M,LOW,IGH,CSCALE)
C
C     *****PARAMETERS:
      INTEGER IGH,LOW,M,MZ,N
      DOUBLE PRECISION CSCALE(N),Z(MZ,N)
C
C     *****LOCAL VARIABLES:
      INTEGER I,IGHP1,II,IR,J,K,LOWM1
      DOUBLE PRECISION FI,TEMP
C
C     *****FORTRAN FUNCTIONS:
C     NONE
C
C     *****SUBROUTINES CALLED:
C     NONE
C
C     ---------------------------------------------------------------
C
C     *****PURPOSE:
C     THIS SUBROUTINE BACK TRANSFORMS THE EIGENVECTORS OF A
C     GENERALIZED EIGENVALUE PROBLEM A*X = (LAMBDA)*B*X BALANCED BY
C     SUBROUTINES REDUCE AND/OR SCALEG TO THOSE OF THE ORIGINAL
C     PROBLEM.
C     REF.:  WARD, R. C., BALANCING THE GENERALIZED EIGENVALUE
C     PROBLEM, SIAM J. SCI. STAT. COMPUT., VOL. 2, NO. 2, JUNE 1981,
C     141-152.
C
C     *****PARAMETER DESCRIPTION:
C
C     ON INPUT:
C
C       MZ      INTEGER
C               ROW DIMENSION OF THE ARRAY Z AS SPECIFIED IN THE MAIN
C               CALLING PROGRAM DIMENSION STATEMENT;
C
C       N       INTEGER
C               ORDER OF THE MATRICES A AND B IN THE EIGENPROBLEM;
C
C       M       INTEGER
C               SPECIFIES THE NUMBER OF EIGENVECTORS TO BE TRANS-
C               FORMED;
C
C       Z       REAL(MZ,N)
C               CONTAINS THE EIGENVECTORS TO BE TRANSFORMED;
C
C       LOW     INTEGER
C               SPECIFIES THE BEGINNING INDEX OF THE SUBMATRICES OF
C               A AND B WHICH WERE SCALED;
C
C       IGH     INTEGER
C               SPECIFIES THE ENDING INDEX OF THE SUBMATRICES OF
C               A AND B WHICH WERE SCALED;
C
C       CSCALE  REAL(N)
C               CONTAINS THE REDUCING COLUMN PERMUTATIONS AND SCALING
C               INFORMATION AS RETURNED FROM REDUCE AND SCALEG.  IF
C               REDUCE WAS NOT CALLED, SET LOW TO 1 AND IGH TO N.
C               IF SCALEG WAS NOT CALLED, SET THE SCALE FACTORS IN
C               CSCALE LOCATIONS LOW THROUGH IGH TO ZERO.
C
C     ON OUTPUT:
C
C       Z       CONTAINS THE TRANSFORMED EIGENVECTORS.
C
C     *****ALGORITHM NOTES:
C     NONE.
C
C     *****HISTORY:
C     WRITTEN BY R. C. WARD.......
C
C     ---------------------------------------------------------------
C
      IF (LOW .EQ. IGH) GO TO 545
C
C     APPLY SCALING TRANSFORMATION
C
      DO 540 I = LOW,IGH
         IR = CSCALE(I)
         FI = 2.0D0**IR
         DO 530 J = 1,M
            Z(I,J) = Z(I,J)*FI
  530    CONTINUE
  540 CONTINUE
  545 CONTINUE
C
C     APPLY REDUCING COLUMN PERMUTATIONS
C
      IF (LOW .EQ. 1) GO TO 570
      LOWM1 = LOW-1
      DO 560 II = 1,LOWM1
         I = LOW-II
         K = CSCALE(I)
         IF (K .EQ. I) GO TO 560
         DO 550 J = 1,M
            TEMP = Z(I,J)
            Z(I,J) = Z(K,J)
            Z(K,J) = TEMP
  550    CONTINUE
  560 CONTINUE
  570 CONTINUE
      IF (IGH .EQ. N) GO TO 600
      IGHP1 = IGH+1
      DO 590 I = IGHP1,N
         K = CSCALE(I)
         IF (K .EQ. I) GO TO 590
         DO 580 J = 1,M
            TEMP = Z(I,J)
            Z(I,J) = Z(K,J)
            Z(K,J) = TEMP
  580    CONTINUE
  590 CONTINUE
  600 CONTINUE
      RETURN
C
C     LAST LINE OF SCALBK
C
      END
      SUBROUTINE SCALEG (N,MA,A,MB,B,LOW,IGH,CSCALE,CPERM,WK)
C
C     *****PARAMETERS:
      INTEGER IGH,LOW,MA,MB,N
      DOUBLE PRECISION A(MA,N),B(MB,N),CPERM(N),CSCALE(N),WK(N,6)
C
C     *****LOCAL VARIABLES:
      INTEGER I,IR,IT,J,JC,KOUNT,NR,NRP2
      DOUBLE PRECISION ALPHA,BASL,BETA,CMAX,COEF,COEF2,COEF5,COR,
     *                 EW,EWC,FI,FJ,GAMMA,PGAMMA,SUM,T,TA,TB,TC
C
C     *****FORTRAN FUNCTIONS:
      DOUBLE PRECISION DABS, DLOG10, DSIGN
C     FLOAT
C
C     *****SUBROUTINES CALLED:
C     NONE
C
C     ---------------------------------------------------------------
C
C     *****PURPOSE:
C     SCALES THE MATRICES A AND B IN THE GENERALIZED EIGENVALUE
C     PROBLEM A*X = (LAMBDA)*B*X SUCH THAT THE MAGNITUDES OF THE
C     ELEMENTS OF THE SUBMATRICES OF A AND B (AS SPECIFIED BY LOW
C     AND IGH) ARE CLOSE TO UNITY IN THE LEAST SQUARES SENSE.
C     REF.:  WARD, R. C., BALANCING THE GENERALIZED EIGENVALUE
C     PROBLEM, SIAM J. SCI. STAT. COMPUT., VOL. 2, NO. 2, JUNE 1981,
C     141-152.
C
C     *****PARAMETER DESCRIPTION:
C
C     ON INPUT:
C
C       MA,MB   INTEGER
C               ROW DIMENSIONS OF THE ARRAYS CONTAINING MATRICES
C               A AND B RESPECTIVELY, AS DECLARED IN THE MAIN CALLING
C               PROGRAM DIMENSION STATEMENT;
C
C       N       INTEGER
C               ORDER OF THE MATRICES A AND B;
C
C       A       REAL(MA,N)
C               CONTAINS THE A MATRIX OF THE GENERALIZED EIGENPROBLEM
C               DEFINED ABOVE;
C
C       B       REAL(MB,N)
C               CONTAINS THE B MATRIX OF THE GENERALIZED EIGENPROBLEM
C               DEFINED ABOVE;
C
C       LOW     INTEGER
C               SPECIFIES THE BEGINNING INDEX FOR THE ROWS AND
C               COLUMNS OF A AND B TO BE SCALED;
C
C       IGH     INTEGER
C               SPECIFIES THE ENDING INDEX FOR THE ROWS AND COLUMNS
C               OF A AND B TO BE SCALED;
C
C       CPERM   REAL(N)
C               WORK ARRAY.  ONLY LOCATIONS LOW THROUGH IGH ARE
C               REFERENCED AND ALTERED BY THIS SUBROUTINE;
C
C       WK      REAL(N,6)
C               WORK ARRAY THAT MUST CONTAIN AT LEAST 6*N LOCATIONS.
C               ONLY LOCATIONS LOW THROUGH IGH, N+LOW THROUGH N+IGH,
C               ..., 5*N+LOW THROUGH 5*N+IGH ARE REFERENCED AND
C               ALTERED BY THIS SUBROUTINE.
C
C     ON OUTPUT:
C
C       A,B     CONTAIN THE SCALED A AND B MATRICES;
C
C       CSCALE  REAL(N)
C               CONTAINS IN ITS LOW THROUGH IGH LOCATIONS THE INTEGER
C               EXPONENTS OF 2 USED FOR THE COLUMN SCALING FACTORS.
C               THE OTHER LOCATIONS ARE NOT REFERENCED;
C
C       WK      CONTAINS IN ITS LOW THROUGH IGH LOCATIONS THE INTEGER
C               EXPONENTS OF 2 USED FOR THE ROW SCALING FACTORS.
C
C     *****ALGORITHM NOTES:
C     NONE.
C
C     *****HISTORY:
C     WRITTEN BY R. C. WARD.......
C     Modified 8/86 by Bobby Bodenheimer so that if
C       SUM = 0 (corresponding to the case where the matrix
C       doesn't need to be scaled) the routine returns.
C
C     ---------------------------------------------------------------
C
      IF (LOW .EQ. IGH) GO TO 410
      DO 210 I = LOW,IGH
         WK(I,1) = 0.0D0
         WK(I,2) = 0.0D0
         WK(I,3) = 0.0D0
         WK(I,4) = 0.0D0
         WK(I,5) = 0.0D0
         WK(I,6) = 0.0D0
         CSCALE(I) = 0.0D0
         CPERM(I) = 0.0D0
  210 CONTINUE
C
C     COMPUTE RIGHT SIDE VECTOR IN RESULTING LINEAR EQUATIONS
C
      BASL = DLOG10(2.0D0)
      DO 240 I = LOW,IGH
         DO 241 J = LOW,IGH
            TB = B(I,J)
            TA = A(I,J)
            IF (TA .EQ. 0.0D0) GO TO 220
            TA = DLOG10(DABS(TA)) / BASL
  220       CONTINUE
            IF (TB .EQ. 0.0D0) GO TO 230
            TB = DLOG10(DABS(TB)) / BASL
  230       CONTINUE
            WK(I,5) = WK(I,5) - TA - TB
            WK(J,6) = WK(J,6) - TA - TB
  241    CONTINUE
  240 CONTINUE
      NR = IGH-LOW+1
      COEF = 1.0D0/FLOAT(2*NR)
      COEF2 = COEF*COEF
      COEF5 = 0.5D0*COEF2
      NRP2 = NR+2
      BETA = 0.0D0
      IT = 1
C
C     START GENERALIZED CONJUGATE GRADIENT ITERATION
C
  250 CONTINUE
      EW = 0.0D0
      EWC = 0.0D0
      GAMMA = 0.0D0
      DO 260 I = LOW,IGH
         GAMMA = GAMMA + WK(I,5)*WK(I,5) + WK(I,6)*WK(I,6)
         EW = EW + WK(I,5)
         EWC = EWC + WK(I,6)
  260 CONTINUE
      GAMMA = COEF*GAMMA - COEF2*(EW**2 + EWC**2)
     +        - COEF5*(EW - EWC)**2
      IF (IT .NE. 1) BETA = GAMMA / PGAMMA
      T = COEF5*(EWC - 3.0D0*EW)
      TC = COEF5*(EW - 3.0D0*EWC)
      DO 270 I = LOW,IGH
         WK(I,2) = BETA*WK(I,2) + COEF*WK(I,5) + T
         CPERM(I) = BETA*CPERM(I) + COEF*WK(I,6) + TC
  270 CONTINUE
C
C     APPLY MATRIX TO VECTOR
C
      DO 300 I = LOW,IGH
         KOUNT = 0
         SUM = 0.0D0
         DO 290 J = LOW,IGH
            IF (A(I,J) .EQ. 0.0D0) GO TO 280
            KOUNT = KOUNT+1
            SUM = SUM + CPERM(J)
  280       CONTINUE
            IF (B(I,J) .EQ. 0.0D0) GO TO 290
            KOUNT = KOUNT+1
            SUM = SUM + CPERM(J)
  290    CONTINUE
         WK(I,3) = FLOAT(KOUNT)*WK(I,2) + SUM
  300 CONTINUE
      DO 330 J = LOW,IGH
         KOUNT = 0
         SUM = 0.0D0
         DO 320 I = LOW,IGH
            IF (A(I,J) .EQ. 0.0D0) GO TO 310
            KOUNT = KOUNT+1
            SUM = SUM + WK(I,2)
  310       CONTINUE
            IF (B(I,J) .EQ. 0.0D0) GO TO 320
            KOUNT = KOUNT+1
            SUM = SUM + WK(I,2)
  320    CONTINUE
         WK(J,4) = FLOAT(KOUNT)*CPERM(J) + SUM
  330 CONTINUE
      SUM = 0.0D0
      DO 340 I = LOW,IGH
         SUM = SUM + WK(I,2)*WK(I,3) + CPERM(I)*WK(I,4)
  340 CONTINUE
      IF(SUM.EQ.0.0D0) RETURN
      ALPHA = GAMMA / SUM
C
C     DETERMINE CORRECTION TO CURRENT ITERATE
C
      CMAX = 0.0D0
      DO 350 I = LOW,IGH
         COR = ALPHA * WK(I,2)
         IF (DABS(COR) .GT. CMAX) CMAX = DABS(COR)
         WK(I,1) = WK(I,1) + COR
         COR = ALPHA * CPERM(I)
         IF (DABS(COR) .GT. CMAX) CMAX = DABS(COR)
         CSCALE(I) = CSCALE(I) + COR
  350 CONTINUE
      IF (CMAX .LT. 0.5D0) GO TO 370
      DO 360 I = LOW,IGH
         WK(I,5) = WK(I,5) - ALPHA*WK(I,3)
         WK(I,6) = WK(I,6) - ALPHA*WK(I,4)
  360 CONTINUE
      PGAMMA = GAMMA
      IT = IT+1
      IF (IT .LE. NRP2) GO TO 250
C
C     END GENERALIZED CONJUGATE GRADIENT ITERATION
C
  370 CONTINUE
      DO 380 I = LOW,IGH
         IR = WK(I,1) + DSIGN(0.5D0,WK(I,1))
         WK(I,1) = IR
         JC = CSCALE(I) + DSIGN(0.5D0,CSCALE(I))
         CSCALE(I) = JC
  380 CONTINUE
C
C     SCALE A AND B
C
      DO 400 I = 1,IGH
         IR = WK(I,1)
         FI = 2.0D0**IR
         IF (I .LT. LOW) FI = 1.0D0
         DO 401 J =LOW,N
            JC = CSCALE(J)
            FJ = 2.0D0**JC
            IF (J .LE. IGH) GO TO 390
            IF (I .LT. LOW) GO TO 401
            FJ = 1.0D0
  390       CONTINUE
            A(I,J) = A(I,J)*FI*FJ
            B(I,J) = B(I,J)*FI*FJ
  401    CONTINUE
  400 CONTINUE
  410 CONTINUE
      RETURN
C
C     LAST LINE OF SCALEG
C
      END
      SUBROUTINE TRNATB(N1,N2,N,M,A,B)
      DOUBLE PRECISION   A(N1,M)
      DOUBLE PRECISION   B(N2,N)
      DOUBLE PRECISION   TEMP
C
C  DESCRIPTION:
C
C  FORM MATRIX TRANSPOSE B = A-TRANSPOSE
C
C  ON INPUT:
C  A IS N X M IN N1 X M ARRAY
C
C  ON OUTPUT:
C  B IS M X N IN N2 X N ARRAY
C  B AND A MAY BE THE SAME;IF SO, N1 MUST = N2.
C
C  WRITTEN BY:  J. DOUGLAS BIRDWELL
C               DEPT. OF ELEC. ENGR.
C               FERRIS 311
C               UNIVERSITY OF TENNESSEE
C               KNOXVILLE, TN  37996-2100
C               (615) 974-5468
C
C  REVISED BY:  DENNIS A. REED
C               JUNE 22,1980
C               bb:8/18/86
C 
       NN=MIN0(M,N)
      DO 1000 I = 1, NN
         DO 1001 J = 1, I
            TEMP = A(J,I)
            B(J,I) = A(I,J)
            B(I,J) = TEMP
1001     continue
1000  continue
      IF(M-N)1050,2000,1200
1050  MP1=M+1
      DO 1100 I=1,M
         DO 1101 J=MP1,N
            B(I,J)=A(J,I)
1101     continue
1100  continue
      GO TO 2000
      NP1=N+1
1200  continue 
      DO 1300 I=NP1,M
         DO 1301 J=1,N
            B(I,J)=A(J,I)
1301     continue
1300  continue
2000  RETURN
      END
